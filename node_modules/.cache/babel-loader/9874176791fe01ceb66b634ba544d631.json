{"ast":null,"code":"/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n * \n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * \n * See the License for the specific language governing permissions and limitations under the License.\n * \n */\n!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == typeof exports ? exports.OktaAuth = t() : e.OktaAuth = t();\n}(\"undefined\" != typeof self ? self : this, function () {\n  return function (e) {\n    function t(n) {\n      if (r[n]) return r[n].exports;\n      var o = r[n] = {\n        i: n,\n        l: !1,\n        exports: {}\n      };\n      return e[n].call(o.exports, o, o.exports, t), o.l = !0, o.exports;\n    }\n\n    var r = {};\n    return t.m = e, t.c = r, t.d = function (e, r, n) {\n      t.o(e, r) || Object.defineProperty(e, r, {\n        configurable: !1,\n        enumerable: !0,\n        get: n\n      });\n    }, t.n = function (e) {\n      var r = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return t.d(r, \"a\", r), r;\n    }, t.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, t.p = \"\", t(t.s = 11);\n  }([function (e, t) {\n    var r = e.exports;\n    r.stringToBase64Url = function (e) {\n      var t = btoa(e);\n      return r.base64ToBase64Url(t);\n    }, r.base64ToBase64Url = function (e) {\n      return e.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n    }, r.base64UrlToBase64 = function (e) {\n      return e.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    }, r.base64UrlToString = function (e) {\n      var t = r.base64UrlToBase64(e);\n\n      switch (t.length % 4) {\n        case 0:\n          break;\n\n        case 2:\n          t += \"==\";\n          break;\n\n        case 3:\n          t += \"=\";\n          break;\n\n        default:\n          throw \"Not a valid Base64Url\";\n      }\n\n      var n = atob(t);\n\n      try {\n        return decodeURIComponent(escape(n));\n      } catch (e) {\n        return n;\n      }\n    }, r.stringToBuffer = function (e) {\n      for (var t = new Uint8Array(e.length), r = 0; r < e.length; r++) t[r] = e.charCodeAt(r);\n\n      return t;\n    }, r.base64UrlDecode = function (e) {\n      return atob(r.base64UrlToBase64(e));\n    }, r.bind = function (e, t) {\n      var r = Array.prototype.slice.call(arguments, 2);\n      return function () {\n        var n = Array.prototype.slice.call(arguments);\n        return n = r.concat(n), e.apply(t, n);\n      };\n    }, r.isAbsoluteUrl = function (e) {\n      return /^(?:[a-z]+:)?\\/\\//i.test(e);\n    }, r.isString = function (e) {\n      return \"[object String]\" === Object.prototype.toString.call(e);\n    }, r.isObject = function (e) {\n      return \"[object Object]\" === Object.prototype.toString.call(e);\n    }, r.isNumber = function (e) {\n      return \"[object Number]\" === Object.prototype.toString.call(e);\n    }, r.isoToUTCString = function (e) {\n      var t = e.match(/\\d+/g),\n          r = Date.UTC(t[0], t[1] - 1, t[2], t[3], t[4], t[5]);\n      return new Date(r).toUTCString();\n    }, r.toQueryParams = function (e) {\n      var t = [];\n      if (null !== e) for (var r in e) e.hasOwnProperty(r) && void 0 !== e[r] && null !== e[r] && t.push(r + \"=\" + encodeURIComponent(e[r]));\n      return t.length ? \"?\" + t.join(\"&\") : \"\";\n    }, r.genRandomString = function (e) {\n      for (var t = \"abcdefghijklnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\", r = \"\", n = 0, o = t.length; n < e; ++n) r += t[Math.floor(Math.random() * o)];\n\n      return r;\n    }, r.extend = function () {\n      var e = arguments[0];\n      return [].slice.call(arguments, 1).forEach(function (t) {\n        for (var r in t) t.hasOwnProperty(r) && void 0 !== t[r] && (e[r] = t[r]);\n      }), e;\n    }, r.removeNils = function (e) {\n      var t = {};\n\n      for (var r in e) if (e.hasOwnProperty(r)) {\n        var n = e[r];\n        null !== n && void 0 !== n && (t[r] = n);\n      }\n\n      return t;\n    }, r.clone = function (e) {\n      if (e) {\n        var t = JSON.stringify(e);\n        if (t) return JSON.parse(t);\n      }\n\n      return e;\n    }, r.omit = function (e) {\n      var t = Array.prototype.slice.call(arguments, 1),\n          n = {};\n\n      for (var o in e) e.hasOwnProperty(o) && -1 == t.indexOf(o) && (n[o] = e[o]);\n\n      return r.clone(n);\n    }, r.find = function (e, t) {\n      for (var r = e.length; r--;) {\n        var n = e[r],\n            o = !0;\n\n        for (var i in t) if (t.hasOwnProperty(i) && n[i] !== t[i]) {\n          o = !1;\n          break;\n        }\n\n        if (o) return n;\n      }\n    }, r.getLink = function (e, t, n) {\n      if (e && e._links) {\n        var o = r.clone(e._links[t]);\n        return o && o.name && n ? o.name === n ? o : void 0 : o;\n      }\n    }, r.getNativeConsole = function () {\n      return \"undefined\" != typeof window ? window.console : \"undefined\" != typeof console ? console : void 0;\n    }, r.getConsole = function () {\n      var e = r.getNativeConsole();\n      return e && e.log ? e : {\n        log: function () {}\n      };\n    }, r.warn = function (e) {\n      r.getConsole().log(\"[okta-auth-sdk] WARN: \" + e);\n    }, r.deprecate = function (e) {\n      r.getConsole().log(\"[okta-auth-sdk] DEPRECATION: \" + e);\n    }, r.deprecateWrap = function (e, t) {\n      return function () {\n        return r.deprecate(e), t.apply(null, arguments);\n      };\n    }, r.removeTrailingSlash = function (e) {\n      if (e) {\n        var t = e.replace(/^\\s+|\\s+$/gm, \"\");\n        return t = t.replace(/\\/+$/, \"\");\n      }\n    }, r.isIE11OrLess = function () {\n      return !!document.documentMode && document.documentMode <= 11;\n    }, r.isFunction = function (e) {\n      return !!e && \"[object Function]\" === {}.toString.call(e);\n    }, r.delay = function (e) {\n      return new Promise(function (t) {\n        setTimeout(t, e);\n      });\n    }, r.isPromise = function (e) {\n      return e && e.finally && \"function\" == typeof e.finally;\n    };\n  }, function (e, t) {\n    function r(e, t) {\n      this.name = \"AuthSdkError\", this.message = e, this.errorCode = \"INTERNAL\", this.errorSummary = e, this.errorLink = \"INTERNAL\", this.errorId = \"INTERNAL\", this.errorCauses = [], t && (this.xhr = t);\n    }\n\n    r.prototype = new Error(), e.exports = r;\n  }, function (e, t, r) {\n    var n = r(14),\n        o = r(7),\n        i = r(3),\n        s = r(1),\n        a = {};\n    a.browserHasLocalStorage = function () {\n      try {\n        var e = a.getLocalStorage();\n        return a.testStorage(e);\n      } catch (e) {\n        return !1;\n      }\n    }, a.browserHasSessionStorage = function () {\n      try {\n        var e = a.getSessionStorage();\n        return a.testStorage(e);\n      } catch (e) {\n        return !1;\n      }\n    }, a.getPKCEStorage = function (e) {\n      return e = e || {}, !e.preferLocalStorage && a.browserHasSessionStorage() ? o(a.getSessionStorage(), i.PKCE_STORAGE_NAME) : a.browserHasLocalStorage() ? o(a.getLocalStorage(), i.PKCE_STORAGE_NAME) : o(a.getCookieStorage(e), i.PKCE_STORAGE_NAME);\n    }, a.getHttpCache = function (e) {\n      return a.browserHasLocalStorage() ? o(a.getLocalStorage(), i.CACHE_STORAGE_NAME) : a.browserHasSessionStorage() ? o(a.getSessionStorage(), i.CACHE_STORAGE_NAME) : o(a.getCookieStorage(e), i.CACHE_STORAGE_NAME);\n    }, a.getLocalStorage = function () {\n      return localStorage;\n    }, a.getSessionStorage = function () {\n      return sessionStorage;\n    }, a.getCookieStorage = function (e) {\n      var t = e.secure,\n          r = e.sameSite;\n      if (void 0 === t || void 0 === r) throw new s('getCookieStorage: \"secure\" and \"sameSite\" options must be provided');\n      return {\n        getItem: a.storage.get,\n        setItem: function (e, n) {\n          a.storage.set(e, n, \"2200-01-01T00:00:00.000Z\", {\n            secure: t,\n            sameSite: r\n          });\n        }\n      };\n    }, a.getInMemoryStorage = function () {\n      var e = {};\n      return {\n        getItem: function (t) {\n          return e[t];\n        },\n        setItem: function (t, r) {\n          e[t] = r;\n        }\n      };\n    }, a.testStorage = function (e) {\n      var t = \"okta-test-storage\";\n\n      try {\n        return e.setItem(t, t), e.removeItem(t), !0;\n      } catch (e) {\n        return !1;\n      }\n    }, a.storage = {\n      set: function (e, t, r, o) {\n        var i = o.secure,\n            u = o.sameSite;\n        if (void 0 === i || void 0 === u) throw new s('storage.set: \"secure\" and \"sameSite\" options must be provided');\n        var c = {\n          path: o.path || \"/\",\n          secure: i,\n          sameSite: u\n        };\n        return Date.parse(r) && (c.expires = new Date(r)), n.set(e, t, c), a.storage.get(e);\n      },\n      get: function (e) {\n        return n.get(e);\n      },\n      delete: function (e) {\n        return n.remove(e, {\n          path: \"/\"\n        });\n      }\n    }, e.exports = a;\n  }, function (e, t) {\n    e.exports = {\n      STATE_TOKEN_KEY_NAME: \"oktaStateToken\",\n      DEFAULT_POLLING_DELAY: 500,\n      DEFAULT_MAX_CLOCK_SKEW: 300,\n      DEFAULT_CACHE_DURATION: 86400,\n      REDIRECT_OAUTH_PARAMS_NAME: \"okta-oauth-redirect-params\",\n      REDIRECT_STATE_COOKIE_NAME: \"okta-oauth-state\",\n      REDIRECT_NONCE_COOKIE_NAME: \"okta-oauth-nonce\",\n      TOKEN_STORAGE_NAME: \"okta-token-storage\",\n      CACHE_STORAGE_NAME: \"okta-cache-storage\",\n      PKCE_STORAGE_NAME: \"okta-pkce-storage\",\n      ACCESS_TOKEN_STORAGE_KEY: \"accessToken\",\n      ID_TOKEN_STORAGE_KEY: \"idToken\"\n    };\n  }, function (e, t, r) {\n    function n(e, t) {\n      t = t || {};\n      var r = t.url,\n          n = t.method,\n          o = t.args,\n          i = t.saveAuthnState,\n          c = t.accessToken,\n          l = !1 !== t.withCredentials,\n          f = e.options.storageUtil,\n          p = f.storage,\n          h = f.getHttpCache(e.options.cookies);\n\n      if (t.cacheResponse) {\n        var d = h.getStorage(),\n            g = d[r];\n        if (g && Date.now() / 1e3 < g.expiresAt) return Promise.resolve(g.response);\n      }\n\n      var m = {\n        Accept: \"application/json\",\n        \"Content-Type\": \"application/json\",\n        \"X-Okta-User-Agent-Extended\": e.userAgent\n      };\n      s.extend(m, e.options.headers, t.headers), c && s.isString(c) && (m.Authorization = \"Bearer \" + c);\n      var y,\n          v,\n          w = {\n        headers: m,\n        data: o || void 0,\n        withCredentials: l\n      };\n      return e.options.httpRequestClient(n, r, w).then(function (n) {\n        return v = n.responseText, v && s.isString(v) && (v = JSON.parse(v)), i && (v.stateToken || p.delete(u.STATE_TOKEN_KEY_NAME)), v && v.stateToken && v.expiresAt && p.set(u.STATE_TOKEN_KEY_NAME, v.stateToken, v.expiresAt, e.options.cookies), v && t.cacheResponse && h.updateStorage(r, {\n          expiresAt: Math.floor(Date.now() / 1e3) + u.DEFAULT_CACHE_DURATION,\n          response: v\n        }), v;\n      }).catch(function (t) {\n        var r = t.responseText || {};\n        if (s.isString(r)) try {\n          r = JSON.parse(r);\n        } catch (e) {\n          r = {\n            errorSummary: \"Unknown error\"\n          };\n        }\n        throw t.status >= 500 && (r.errorSummary = \"Unknown error\"), e.options.transformErrorXHR && (t = e.options.transformErrorXHR(s.clone(t))), y = new a(r, t), \"E0000011\" === y.errorCode && p.delete(u.STATE_TOKEN_KEY_NAME), y;\n      });\n    }\n\n    function o(e, t, r) {\n      t = s.isAbsoluteUrl(t) ? t : e.getIssuerOrigin() + t;\n      var o = {\n        url: t,\n        method: \"GET\"\n      };\n      return s.extend(o, r), n(e, o);\n    }\n\n    function i(e, t, r, o) {\n      t = s.isAbsoluteUrl(t) ? t : e.getIssuerOrigin() + t;\n      var i = {\n        url: t,\n        method: \"POST\",\n        args: r,\n        saveAuthnState: !0\n      };\n      return s.extend(i, o), n(e, i);\n    }\n\n    var s = r(0),\n        a = r(19),\n        u = r(3);\n    e.exports = {\n      get: o,\n      post: i,\n      httpRequest: n\n    };\n  }, function (e, t, r) {\n    function n() {\n      return w.genRandomString(64);\n    }\n\n    function o() {\n      return w.genRandomString(64);\n    }\n\n    function i(e) {\n      return !(!e || !e.accessToken && !e.idToken || !Array.isArray(e.scopes));\n    }\n\n    function s(e, t, r) {\n      e.addEventListener ? e.addEventListener(t, r) : e.attachEvent(\"on\" + t, r);\n    }\n\n    function a(e, t, r) {\n      e.removeEventListener ? e.removeEventListener(t, r) : e.detachEvent(\"on\" + t, r);\n    }\n\n    function u(e) {\n      var t = document.createElement(\"iframe\");\n      return t.style.display = \"none\", t.src = e, document.body.appendChild(t);\n    }\n\n    function c(e, t) {\n      var r = t.popupTitle || \"External Identity Provider User Authentication\",\n          n = \"toolbar=no, scrollbars=yes, resizable=yes, top=100, left=500, width=600, height=600\";\n\n      if (w.isIE11OrLess()) {\n        var o = window.open(\"/\", r, n);\n        return o.location.href = e, o;\n      }\n\n      return window.open(e, r, n);\n    }\n\n    function l(e, t) {\n      var r = t || e.options.issuer;\n      return v.get(e, r + \"/.well-known/openid-configuration\", {\n        cacheResponse: !0\n      });\n    }\n\n    function f(e, t, r) {\n      var n = T.getHttpCache(e.options.cookies);\n      return l(e, t).then(function (t) {\n        var o = t.jwks_uri,\n            i = n.getStorage(),\n            s = i[o];\n\n        if (s && Date.now() / 1e3 < s.expiresAt) {\n          var a = w.find(s.response.keys, {\n            kid: r\n          });\n          if (a) return a;\n        }\n\n        return n.clearStorage(o), v.get(e, o, {\n          cacheResponse: !0\n        }).then(function (e) {\n          var t = w.find(e.keys, {\n            kid: r\n          });\n          if (t) return t;\n          throw new k(\"The key id, \" + r + \", was not found in the server's keys\");\n        });\n      });\n    }\n\n    function p(e, t, r) {\n      var n = r.clientId,\n          o = r.issuer,\n          i = r.nonce;\n      if (!t || !o || !n) throw new k(\"The jwt, iss, and aud arguments are all required\");\n      if (i && t.nonce !== i) throw new k(\"OAuth flow response nonce doesn't match request nonce\");\n      var s = Math.floor(Date.now() / 1e3);\n      if (t.iss !== o) throw new k(\"The issuer [\" + t.iss + \"] does not match [\" + o + \"]\");\n      if (t.aud !== n) throw new k(\"The audience [\" + t.aud + \"] does not match [\" + n + \"]\");\n      if (t.iat > t.exp) throw new k(\"The JWT expired before it was issued\");\n      if (s - e.options.maxClockSkew > t.exp) throw new k(\"The JWT expired and is no longer valid\");\n      if (t.iat > s + e.options.maxClockSkew) throw new k(\"The JWT was issued in the future\");\n    }\n\n    function h(e, t) {\n      if (arguments.length > 2) throw new k('As of version 3.0, \"getOAuthUrls\" takes only a single set of options');\n      t = t || {};\n      var r = w.removeTrailingSlash(t.authorizeUrl) || e.options.authorizeUrl,\n          n = w.removeTrailingSlash(t.issuer) || e.options.issuer,\n          o = w.removeTrailingSlash(t.userinfoUrl) || e.options.userinfoUrl,\n          i = w.removeTrailingSlash(t.tokenUrl) || e.options.tokenUrl,\n          s = w.removeTrailingSlash(t.logoutUrl) || e.options.logoutUrl,\n          a = w.removeTrailingSlash(t.revokeUrl) || e.options.revokeUrl,\n          u = n.indexOf(\"/oauth2\") > 0 ? n : n + \"/oauth2\";\n      return r = r || u + \"/v1/authorize\", o = o || u + \"/v1/userinfo\", i = i || u + \"/v1/token\", a = a || u + \"/v1/revoke\", s = s || u + \"/v1/logout\", {\n        issuer: n,\n        authorizeUrl: r,\n        userinfoUrl: o,\n        tokenUrl: i,\n        revokeUrl: a,\n        logoutUrl: s\n      };\n    }\n\n    function d(e) {\n      var t = /\\+/g,\n          r = /([^&=]+)=?([^&]*)/g,\n          n = e;\n      \"#\" === n.charAt(0) && \"/\" === n.charAt(1) && (n = n.substring(2)), \"#\" !== n.charAt(0) && \"?\" !== n.charAt(0) || (n = n.substring(1));\n\n      for (var o, i = {};;) {\n        if (!(o = r.exec(n))) break;\n        var s = o[1],\n            a = o[2];\n        i[s] = \"id_token\" === s || \"access_token\" === s || \"code\" === s ? a : decodeURIComponent(a.replace(t, \" \"));\n      }\n\n      return i;\n    }\n\n    function g(e) {\n      return /((id|access)_token=)/i.test(e);\n    }\n\n    function m(e) {\n      return /(code=)/i.test(e);\n    }\n\n    function y(e) {\n      var t = e.options;\n      return t.pkce || \"code\" === t.responseType || \"query\" === t.responseMode ? m(\"fragment\" === t.responseMode ? window.location.hash : window.location.search) : g(window.location.hash);\n    }\n\n    var v = r(4),\n        w = r(0),\n        T = r(2),\n        k = r(1);\n    e.exports = {\n      generateState: n,\n      generateNonce: o,\n      getWellKnown: l,\n      getKey: f,\n      validateClaims: p,\n      getOAuthUrls: h,\n      loadFrame: u,\n      loadPopup: c,\n      urlParamsToObject: d,\n      isToken: i,\n      addListener: s,\n      removeListener: a,\n      isLoginRedirect: y\n    };\n  }, function (e, t) {\n    function r(t) {\n      return \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? e.exports = r = function (e) {\n        return typeof e;\n      } : e.exports = r = function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n      }, r(t);\n    }\n\n    e.exports = r;\n  }, function (e, t, r) {\n    function n(e, t) {\n      function r() {\n        var r = e.getItem(t);\n        r = r || \"{}\";\n\n        try {\n          return JSON.parse(r);\n        } catch (e) {\n          throw new o(\"Unable to parse storage string: \" + t);\n        }\n      }\n\n      function n(r) {\n        try {\n          var n = JSON.stringify(r);\n          e.setItem(t, n);\n        } catch (e) {\n          throw new o(\"Unable to set storage: \" + t);\n        }\n      }\n\n      function i(e) {\n        if (!e) return n({});\n        var t = r();\n        delete t[e], n(t);\n      }\n\n      function s(e, t) {\n        var o = r();\n        o[e] = t, n(o);\n      }\n\n      if (\"string\" != typeof t || !t.length) throw new o('\"storageName\" is required');\n      return {\n        getStorage: r,\n        setStorage: n,\n        clearStorage: i,\n        updateStorage: s\n      };\n    }\n\n    var o = r(1);\n    e.exports = n;\n  }, function (e, t, r) {\n    e.exports = r(16);\n  }, function (e, t) {\n    function r(e, t, r, n, o, i, s) {\n      try {\n        var a = e[i](s),\n            u = a.value;\n      } catch (e) {\n        return void r(e);\n      }\n\n      a.done ? t(u) : Promise.resolve(u).then(n, o);\n    }\n\n    function n(e) {\n      return function () {\n        var t = this,\n            n = arguments;\n        return new Promise(function (o, i) {\n          function s(e) {\n            r(u, o, i, s, a, \"next\", e);\n          }\n\n          function a(e) {\n            r(u, o, i, s, a, \"throw\", e);\n          }\n\n          var u = e.apply(t, n);\n          s(void 0);\n        });\n      };\n    }\n\n    e.exports = n;\n  }, function (e, t, r) {\n    function n(e, t) {\n      var r = {};\n      return y.extend(r, t), !r.stateToken && e.stateToken && (r.stateToken = e.stateToken), r;\n    }\n\n    function o(e) {\n      return n(e);\n    }\n\n    function i(e, t) {\n      return t = n(e, t), m.post(e, e.getIssuerOrigin() + \"/api/v1/authn\", t);\n    }\n\n    function s(e, t) {\n      if (!t || !t.stateToken) {\n        var r = e.tx.exists._get(T.STATE_TOKEN_KEY_NAME);\n\n        if (!r) return Promise.reject(new v(\"No transaction to resume\"));\n        t = {\n          stateToken: r\n        };\n      }\n\n      return e.tx.status(t).then(function (t) {\n        return new g(e, t);\n      });\n    }\n\n    function a(e, t) {\n      if (!t || !t.stateToken) {\n        var r = e.tx.exists._get(T.STATE_TOKEN_KEY_NAME);\n\n        if (!r) return Promise.reject(new v(\"No transaction to evaluate\"));\n        t = {\n          stateToken: r\n        };\n      }\n\n      return u(e, t).then(function (t) {\n        return new g(e, t);\n      });\n    }\n\n    function u(e, t) {\n      return t = n(e, t), m.post(e, e.getIssuerOrigin() + \"/api/v1/authn/introspect\", t);\n    }\n\n    function c(e) {\n      return !!e.tx.exists._get(T.STATE_TOKEN_KEY_NAME);\n    }\n\n    function l(e, t, r, n) {\n      return m.post(e, t, r, n).then(function (t) {\n        return new g(e, t);\n      });\n    }\n\n    function f(e, t, r) {\n      return function (n) {\n        function i() {\n          var r = {};\n          if (\"function\" == typeof u) try {\n            r.autoPush = !!u();\n          } catch (e) {\n            return Promise.reject(new v(\"AutoPush resulted in an error.\"));\n          } else void 0 !== u && null !== u && (r.autoPush = !!u);\n          if (\"function\" == typeof a) try {\n            r.rememberDevice = !!a();\n          } catch (e) {\n            return Promise.reject(new v(\"RememberDevice resulted in an error.\"));\n          } else void 0 !== a && null !== a && (r.rememberDevice = !!a);\n          var n = l.href + y.toQueryParams(r);\n          return m.post(e, n, o(t), {\n            saveAuthnState: !1\n          });\n        }\n\n        var s, a, u, c;\n        y.isNumber(n) ? s = n : y.isObject(n) && (s = n.delay, a = n.rememberDevice, u = n.autoPush, c = n.transactionCallBack), s || 0 === s || (s = T.DEFAULT_POLLING_DELAY);\n        var l = y.getLink(t, \"next\", \"poll\");\n        r.isPolling = !0;\n        var f = 0;\n        return function t() {\n          return r.isPolling ? i().then(function (n) {\n            if (f = 0, n.factorResult && \"WAITING\" === n.factorResult) {\n              if (!r.isPolling) throw new w();\n              return \"function\" == typeof c && c(n), y.delay(s).then(t);\n            }\n\n            return r.isPolling = !1, new g(e, n);\n          }).catch(function (e) {\n            if (e.xhr && (0 === e.xhr.status || 429 === e.xhr.status) && f <= 4) {\n              var r = 1e3 * Math.pow(2, f);\n              return f++, y.delay(r).then(t);\n            }\n\n            throw e;\n          }) : Promise.reject(new w());\n        }().catch(function (e) {\n          throw r.isPolling = !1, e;\n        });\n      };\n    }\n\n    function p(e, t, r, o, i) {\n      if (Array.isArray(o)) return function (n, s) {\n        if (!n) throw new v(\"Must provide a link name\");\n        var a = y.find(o, {\n          name: n\n        });\n        if (!a) throw new v(\"No link found for that name\");\n        return p(e, t, r, a, i)(s);\n      };\n\n      if (o.hints && o.hints.allow && 1 === o.hints.allow.length) {\n        switch (o.hints.allow[0]) {\n          case \"GET\":\n            return function () {\n              return m.get(e, o.href);\n            };\n\n          case \"POST\":\n            return function (s) {\n              i && i.isPolling && (i.isPolling = !1);\n              var a = n(t, s);\n              \"MFA_ENROLL\" !== t.status && \"FACTOR_ENROLL\" !== t.status || y.extend(a, {\n                factorType: r.factorType,\n                provider: r.provider\n              });\n              var u = {},\n                  c = a.autoPush;\n\n              if (void 0 !== c) {\n                if (\"function\" == typeof c) try {\n                  u.autoPush = !!c();\n                } catch (e) {\n                  return Promise.reject(new v(\"AutoPush resulted in an error.\"));\n                } else null !== c && (u.autoPush = !!c);\n                a = y.omit(a, \"autoPush\");\n              }\n\n              var f = a.rememberDevice;\n\n              if (void 0 !== f) {\n                if (\"function\" == typeof f) try {\n                  u.rememberDevice = !!f();\n                } catch (e) {\n                  return Promise.reject(new v(\"RememberDevice resulted in an error.\"));\n                } else null !== f && (u.rememberDevice = !!f);\n                a = y.omit(a, \"rememberDevice\");\n              } else a.profile && void 0 !== a.profile.updatePhone && (a.profile.updatePhone && (u.updatePhone = !0), a.profile = y.omit(a.profile, \"updatePhone\"));\n\n              var p = o.href + y.toQueryParams(u);\n              return l(e, p, a);\n            };\n        }\n      }\n    }\n\n    function h(e, t, r, n) {\n      var o = {};\n\n      for (var i in r._links) if (r._links.hasOwnProperty(i)) {\n        var s = r._links[i];\n        if (\"next\" === i && (i = s.name), s.type) o[i] = s;else switch (i) {\n          case \"poll\":\n            o.poll = f(e, t, n);\n            break;\n\n          default:\n            var a = p(e, t, r, s, n);\n            a && (o[i] = a);\n        }\n      }\n\n      return o;\n    }\n\n    function d(e, t, r, n) {\n      if (r = r || t, r = y.clone(r), Array.isArray(r)) {\n        for (var o = [], i = 0, s = r.length; i < s; i++) o.push(d(e, t, r[i], n));\n\n        return o;\n      }\n\n      var a = r._embedded || {};\n\n      for (var u in a) a.hasOwnProperty(u) && (y.isObject(a[u]) || Array.isArray(a[u])) && (a[u] = d(e, t, a[u], n));\n\n      var c = h(e, t, r, n);\n      return y.extend(a, c), r = y.omit(r, \"_embedded\", \"_links\"), y.extend(r, a), r;\n    }\n\n    function g(e, t) {\n      t && (this.data = t, y.extend(this, d(e, t, t, {})), delete this.stateToken, \"RECOVERY_CHALLENGE\" !== t.status || t._links || (this.cancel = function () {\n        return Promise.resolve(new g(e));\n      }));\n    }\n\n    var m = r(4),\n        y = r(0),\n        v = r(1),\n        w = r(20),\n        T = r(3);\n    e.exports = {\n      transactionStatus: i,\n      resumeTransaction: s,\n      transactionExists: c,\n      postToTransaction: l,\n      introspect: a\n    };\n  }, function (e, t, r) {\n    var n = r(12),\n        o = r(2);\n    e.exports = r(15)(o, n);\n  }, function (e, t, r) {\n    function n(e) {\n      return e.headers.get(\"Content-Type\") && e.headers.get(\"Content-Type\").toLowerCase().indexOf(\"application/json\") >= 0 ? e.json().catch(function (e) {\n        return {\n          error: e,\n          errorSummary: \"Could not parse server response\"\n        };\n      }) : e.text();\n    }\n\n    function o(e, t) {\n      var r = \"object\" === s(t),\n          n = {\n        responseText: r ? JSON.stringify(t) : t,\n        status: e\n      };\n      return r && (n.responseType = \"json\", n.responseJSON = t), n;\n    }\n\n    function i(e, t, r) {\n      var i = r.data,\n          s = r.headers || {};\n      return \"application/json\" === (s[\"Content-Type\"] || s[\"content-type\"] || \"\") && i && \"string\" != typeof i && (i = JSON.stringify(i)), a(t, {\n        method: e,\n        headers: r.headers,\n        body: i,\n        credentials: r.withCredentials ? \"include\" : \"omit\"\n      }).then(function (e) {\n        var t = !e.ok,\n            r = e.status;\n        return n(e).then(function (e) {\n          return o(r, e);\n        }).then(function (e) {\n          if (t) throw e;\n          return e;\n        });\n      });\n    }\n\n    var s = r(6),\n        a = r(13);\n    e.exports = i;\n  }, function (e, t) {\n    var r = function (e) {\n      function t() {\n        this.fetch = !1, this.DOMException = e.DOMException;\n      }\n\n      return t.prototype = e, new t();\n    }(\"undefined\" != typeof self ? self : this);\n\n    !function (e) {\n      !function (t) {\n        function r(e) {\n          return e && DataView.prototype.isPrototypeOf(e);\n        }\n\n        function n(e) {\n          if (\"string\" != typeof e && (e = String(e)), /[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(e)) throw new TypeError(\"Invalid character in header field name\");\n          return e.toLowerCase();\n        }\n\n        function o(e) {\n          return \"string\" != typeof e && (e = String(e)), e;\n        }\n\n        function i(e) {\n          var t = {\n            next: function () {\n              var t = e.shift();\n              return {\n                done: void 0 === t,\n                value: t\n              };\n            }\n          };\n          return T.iterable && (t[Symbol.iterator] = function () {\n            return t;\n          }), t;\n        }\n\n        function s(e) {\n          this.map = {}, e instanceof s ? e.forEach(function (e, t) {\n            this.append(t, e);\n          }, this) : Array.isArray(e) ? e.forEach(function (e) {\n            this.append(e[0], e[1]);\n          }, this) : e && Object.getOwnPropertyNames(e).forEach(function (t) {\n            this.append(t, e[t]);\n          }, this);\n        }\n\n        function a(e) {\n          if (e.bodyUsed) return Promise.reject(new TypeError(\"Already read\"));\n          e.bodyUsed = !0;\n        }\n\n        function u(e) {\n          return new Promise(function (t, r) {\n            e.onload = function () {\n              t(e.result);\n            }, e.onerror = function () {\n              r(e.error);\n            };\n          });\n        }\n\n        function c(e) {\n          var t = new FileReader(),\n              r = u(t);\n          return t.readAsArrayBuffer(e), r;\n        }\n\n        function l(e) {\n          var t = new FileReader(),\n              r = u(t);\n          return t.readAsText(e), r;\n        }\n\n        function f(e) {\n          for (var t = new Uint8Array(e), r = new Array(t.length), n = 0; n < t.length; n++) r[n] = String.fromCharCode(t[n]);\n\n          return r.join(\"\");\n        }\n\n        function p(e) {\n          if (e.slice) return e.slice(0);\n          var t = new Uint8Array(e.byteLength);\n          return t.set(new Uint8Array(e)), t.buffer;\n        }\n\n        function h() {\n          return this.bodyUsed = !1, this._initBody = function (e) {\n            this._bodyInit = e, e ? \"string\" == typeof e ? this._bodyText = e : T.blob && Blob.prototype.isPrototypeOf(e) ? this._bodyBlob = e : T.formData && FormData.prototype.isPrototypeOf(e) ? this._bodyFormData = e : T.searchParams && URLSearchParams.prototype.isPrototypeOf(e) ? this._bodyText = e.toString() : T.arrayBuffer && T.blob && r(e) ? (this._bodyArrayBuffer = p(e.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : T.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(e) || S(e)) ? this._bodyArrayBuffer = p(e) : this._bodyText = e = Object.prototype.toString.call(e) : this._bodyText = \"\", this.headers.get(\"content-type\") || (\"string\" == typeof e ? this.headers.set(\"content-type\", \"text/plain;charset=UTF-8\") : this._bodyBlob && this._bodyBlob.type ? this.headers.set(\"content-type\", this._bodyBlob.type) : T.searchParams && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set(\"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\"));\n          }, T.blob && (this.blob = function () {\n            var e = a(this);\n            if (e) return e;\n            if (this._bodyBlob) return Promise.resolve(this._bodyBlob);\n            if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n            if (this._bodyFormData) throw new Error(\"could not read FormData body as blob\");\n            return Promise.resolve(new Blob([this._bodyText]));\n          }, this.arrayBuffer = function () {\n            return this._bodyArrayBuffer ? a(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(c);\n          }), this.text = function () {\n            var e = a(this);\n            if (e) return e;\n            if (this._bodyBlob) return l(this._bodyBlob);\n            if (this._bodyArrayBuffer) return Promise.resolve(f(this._bodyArrayBuffer));\n            if (this._bodyFormData) throw new Error(\"could not read FormData body as text\");\n            return Promise.resolve(this._bodyText);\n          }, T.formData && (this.formData = function () {\n            return this.text().then(m);\n          }), this.json = function () {\n            return this.text().then(JSON.parse);\n          }, this;\n        }\n\n        function d(e) {\n          var t = e.toUpperCase();\n          return b.indexOf(t) > -1 ? t : e;\n        }\n\n        function g(e, t) {\n          t = t || {};\n          var r = t.body;\n\n          if (e instanceof g) {\n            if (e.bodyUsed) throw new TypeError(\"Already read\");\n            this.url = e.url, this.credentials = e.credentials, t.headers || (this.headers = new s(e.headers)), this.method = e.method, this.mode = e.mode, this.signal = e.signal, r || null == e._bodyInit || (r = e._bodyInit, e.bodyUsed = !0);\n          } else this.url = String(e);\n\n          if (this.credentials = t.credentials || this.credentials || \"same-origin\", !t.headers && this.headers || (this.headers = new s(t.headers)), this.method = d(t.method || this.method || \"GET\"), this.mode = t.mode || this.mode || null, this.signal = t.signal || this.signal, this.referrer = null, (\"GET\" === this.method || \"HEAD\" === this.method) && r) throw new TypeError(\"Body not allowed for GET or HEAD requests\");\n\n          this._initBody(r);\n        }\n\n        function m(e) {\n          var t = new FormData();\n          return e.trim().split(\"&\").forEach(function (e) {\n            if (e) {\n              var r = e.split(\"=\"),\n                  n = r.shift().replace(/\\+/g, \" \"),\n                  o = r.join(\"=\").replace(/\\+/g, \" \");\n              t.append(decodeURIComponent(n), decodeURIComponent(o));\n            }\n          }), t;\n        }\n\n        function y(e) {\n          var t = new s();\n          return e.replace(/\\r?\\n[\\t ]+/g, \" \").split(/\\r?\\n/).forEach(function (e) {\n            var r = e.split(\":\"),\n                n = r.shift().trim();\n\n            if (n) {\n              var o = r.join(\":\").trim();\n              t.append(n, o);\n            }\n          }), t;\n        }\n\n        function v(e, t) {\n          t || (t = {}), this.type = \"default\", this.status = void 0 === t.status ? 200 : t.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = \"statusText\" in t ? t.statusText : \"OK\", this.headers = new s(t.headers), this.url = t.url || \"\", this._initBody(e);\n        }\n\n        function w(e, r) {\n          return new Promise(function (n, o) {\n            function i() {\n              a.abort();\n            }\n\n            var s = new g(e, r);\n            if (s.signal && s.signal.aborted) return o(new t.DOMException(\"Aborted\", \"AbortError\"));\n            var a = new XMLHttpRequest();\n            a.onload = function () {\n              var e = {\n                status: a.status,\n                statusText: a.statusText,\n                headers: y(a.getAllResponseHeaders() || \"\")\n              };\n              e.url = \"responseURL\" in a ? a.responseURL : e.headers.get(\"X-Request-URL\");\n              var t = \"response\" in a ? a.response : a.responseText;\n              n(new v(t, e));\n            }, a.onerror = function () {\n              o(new TypeError(\"Network request failed\"));\n            }, a.ontimeout = function () {\n              o(new TypeError(\"Network request failed\"));\n            }, a.onabort = function () {\n              o(new t.DOMException(\"Aborted\", \"AbortError\"));\n            }, a.open(s.method, s.url, !0), \"include\" === s.credentials ? a.withCredentials = !0 : \"omit\" === s.credentials && (a.withCredentials = !1), \"responseType\" in a && T.blob && (a.responseType = \"blob\"), s.headers.forEach(function (e, t) {\n              a.setRequestHeader(t, e);\n            }), s.signal && (s.signal.addEventListener(\"abort\", i), a.onreadystatechange = function () {\n              4 === a.readyState && s.signal.removeEventListener(\"abort\", i);\n            }), a.send(void 0 === s._bodyInit ? null : s._bodyInit);\n          });\n        }\n\n        var T = {\n          searchParams: \"URLSearchParams\" in e,\n          iterable: \"Symbol\" in e && \"iterator\" in Symbol,\n          blob: \"FileReader\" in e && \"Blob\" in e && function () {\n            try {\n              return new Blob(), !0;\n            } catch (e) {\n              return !1;\n            }\n          }(),\n          formData: \"FormData\" in e,\n          arrayBuffer: \"ArrayBuffer\" in e\n        };\n        if (T.arrayBuffer) var k = [\"[object Int8Array]\", \"[object Uint8Array]\", \"[object Uint8ClampedArray]\", \"[object Int16Array]\", \"[object Uint16Array]\", \"[object Int32Array]\", \"[object Uint32Array]\", \"[object Float32Array]\", \"[object Float64Array]\"],\n            S = ArrayBuffer.isView || function (e) {\n          return e && k.indexOf(Object.prototype.toString.call(e)) > -1;\n        };\n        s.prototype.append = function (e, t) {\n          e = n(e), t = o(t);\n          var r = this.map[e];\n          this.map[e] = r ? r + \", \" + t : t;\n        }, s.prototype.delete = function (e) {\n          delete this.map[n(e)];\n        }, s.prototype.get = function (e) {\n          return e = n(e), this.has(e) ? this.map[e] : null;\n        }, s.prototype.has = function (e) {\n          return this.map.hasOwnProperty(n(e));\n        }, s.prototype.set = function (e, t) {\n          this.map[n(e)] = o(t);\n        }, s.prototype.forEach = function (e, t) {\n          for (var r in this.map) this.map.hasOwnProperty(r) && e.call(t, this.map[r], r, this);\n        }, s.prototype.keys = function () {\n          var e = [];\n          return this.forEach(function (t, r) {\n            e.push(r);\n          }), i(e);\n        }, s.prototype.values = function () {\n          var e = [];\n          return this.forEach(function (t) {\n            e.push(t);\n          }), i(e);\n        }, s.prototype.entries = function () {\n          var e = [];\n          return this.forEach(function (t, r) {\n            e.push([r, t]);\n          }), i(e);\n        }, T.iterable && (s.prototype[Symbol.iterator] = s.prototype.entries);\n        var b = [\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"];\n        g.prototype.clone = function () {\n          return new g(this, {\n            body: this._bodyInit\n          });\n        }, h.call(g.prototype), h.call(v.prototype), v.prototype.clone = function () {\n          return new v(this._bodyInit, {\n            status: this.status,\n            statusText: this.statusText,\n            headers: new s(this.headers),\n            url: this.url\n          });\n        }, v.error = function () {\n          var e = new v(null, {\n            status: 0,\n            statusText: \"\"\n          });\n          return e.type = \"error\", e;\n        };\n        var E = [301, 302, 303, 307, 308];\n        v.redirect = function (e, t) {\n          if (-1 === E.indexOf(t)) throw new RangeError(\"Invalid status code\");\n          return new v(null, {\n            status: t,\n            headers: {\n              location: e\n            }\n          });\n        }, t.DOMException = e.DOMException;\n\n        try {\n          new t.DOMException();\n        } catch (e) {\n          t.DOMException = function (e, t) {\n            this.message = e, this.name = t;\n            var r = Error(e);\n            this.stack = r.stack;\n          }, t.DOMException.prototype = Object.create(Error.prototype), t.DOMException.prototype.constructor = t.DOMException;\n        }\n\n        w.polyfill = !0, e.fetch || (e.fetch = w, e.Headers = s, e.Request = g, e.Response = v), t.Headers = s, t.Request = g, t.Response = v, t.fetch = w;\n      }({});\n    }(r), delete r.fetch.polyfill, t = r.fetch, t.default = r.fetch, t.fetch = r.fetch, t.Headers = r.Headers, t.Request = r.Request, t.Response = r.Response, e.exports = t;\n  }, function (e, t, r) {\n    var n, o;\n    !function (i) {\n      var s = !1;\n\n      if (n = i, void 0 !== (o = \"function\" == typeof n ? n.call(t, r, t, e) : n) && (e.exports = o), s = !0, e.exports = i(), s = !0, !s) {\n        var a = window.Cookies,\n            u = window.Cookies = i();\n\n        u.noConflict = function () {\n          return window.Cookies = a, u;\n        };\n      }\n    }(function () {\n      function e() {\n        for (var e = 0, t = {}; e < arguments.length; e++) {\n          var r = arguments[e];\n\n          for (var n in r) t[n] = r[n];\n        }\n\n        return t;\n      }\n\n      function t(r) {\n        function n(t, o, i) {\n          var s;\n\n          if (\"undefined\" != typeof document) {\n            if (arguments.length > 1) {\n              if (i = e({\n                path: \"/\"\n              }, n.defaults, i), \"number\" == typeof i.expires) {\n                var a = new Date();\n                a.setMilliseconds(a.getMilliseconds() + 864e5 * i.expires), i.expires = a;\n              }\n\n              i.expires = i.expires ? i.expires.toUTCString() : \"\";\n\n              try {\n                s = JSON.stringify(o), /^[\\{\\[]/.test(s) && (o = s);\n              } catch (e) {}\n\n              o = r.write ? r.write(o, t) : encodeURIComponent(String(o)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent), t = encodeURIComponent(String(t)), t = t.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent), t = t.replace(/[\\(\\)]/g, escape);\n              var u = \"\";\n\n              for (var c in i) i[c] && (u += \"; \" + c, !0 !== i[c] && (u += \"=\" + i[c]));\n\n              return document.cookie = t + \"=\" + o + u;\n            }\n\n            t || (s = {});\n\n            for (var l = document.cookie ? document.cookie.split(\"; \") : [], f = /(%[0-9A-Z]{2})+/g, p = 0; p < l.length; p++) {\n              var h = l[p].split(\"=\"),\n                  d = h.slice(1).join(\"=\");\n              this.json || '\"' !== d.charAt(0) || (d = d.slice(1, -1));\n\n              try {\n                var g = h[0].replace(f, decodeURIComponent);\n                if (d = r.read ? r.read(d, g) : r(d, g) || d.replace(f, decodeURIComponent), this.json) try {\n                  d = JSON.parse(d);\n                } catch (e) {}\n\n                if (t === g) {\n                  s = d;\n                  break;\n                }\n\n                t || (s[g] = d);\n              } catch (e) {}\n            }\n\n            return s;\n          }\n        }\n\n        return n.set = n, n.get = function (e) {\n          return n.call(n, e);\n        }, n.getJSON = function () {\n          return n.apply({\n            json: !0\n          }, [].slice.call(arguments));\n        }, n.defaults = {}, n.remove = function (t, r) {\n          n(t, \"\", e(r, {\n            expires: -1\n          }));\n        }, n.withConverter = t, n;\n      }\n\n      return t(function () {});\n    });\n  }, function (e, t, r) {\n    function n(e, t) {\n      var r = t.cookies || {};\n      return void 0 === r.secure && (r.secure = e.features.isHTTPS()), void 0 === r.sameSite && (r.sameSite = r.secure ? \"none\" : \"lax\"), r.secure && !e.features.isHTTPS() && (console.warn('The current page is not being served with the HTTPS protocol.\\nFor security reasons, we strongly recommend using HTTPS.\\nIf you cannot use HTTPS, set \"cookies.secure\" option to false.'), r.secure = !1), \"none\" !== r.sameSite || r.secure || (r.sameSite = \"lax\"), r;\n    }\n\n    function o(e) {\n      var t = this;\n      c.assertValidConfig(e), this.options = {\n        clientId: e.clientId,\n        issuer: v.removeTrailingSlash(e.issuer),\n        authorizeUrl: v.removeTrailingSlash(e.authorizeUrl),\n        userinfoUrl: v.removeTrailingSlash(e.userinfoUrl),\n        tokenUrl: v.removeTrailingSlash(e.tokenUrl),\n        revokeUrl: v.removeTrailingSlash(e.revokeUrl),\n        logoutUrl: v.removeTrailingSlash(e.logoutUrl),\n        pkce: !1 !== e.pkce,\n        redirectUri: e.redirectUri,\n        postLogoutRedirectUri: e.postLogoutRedirectUri,\n        responseMode: e.responseMode,\n        httpRequestClient: e.httpRequestClient,\n        storageUtil: e.storageUtil,\n        transformErrorXHR: e.transformErrorXHR,\n        headers: e.headers,\n        onSessionExpired: e.onSessionExpired,\n        cookies: n(t, e)\n      }, this.userAgent = c.getUserAgent(e, \"okta-auth-js/\".concat(\"3.2.5\")), e.maxClockSkew || 0 === e.maxClockSkew ? this.options.maxClockSkew = e.maxClockSkew : this.options.maxClockSkew = l.DEFAULT_MAX_CLOCK_SKEW, this.options.ignoreSignature = !!e.ignoreSignature, t.session = {\n        close: v.bind(d.closeSession, null, t),\n        exists: v.bind(d.sessionExists, null, t),\n        get: v.bind(d.getSession, null, t),\n        refresh: v.bind(d.refreshSession, null, t),\n        setCookieAndRedirect: v.bind(d.setCookieAndRedirect, null, t)\n      }, t.tx = {\n        status: v.bind(y.transactionStatus, null, t),\n        resume: v.bind(y.resumeTransaction, null, t),\n        exists: v.bind(y.transactionExists, null, t),\n        introspect: v.bind(y.introspect, null, t)\n      }, t.tx.exists._get = function (e) {\n        return f.get(e);\n      }, t.idToken = {\n        authorize: {\n          _getLocationHref: function () {\n            return window.location.href;\n          }\n        }\n      }, t._tokenQueue = new w(), t.token = {\n        getWithoutPrompt: v.bind(g.getWithoutPrompt, null, t),\n        getWithPopup: v.bind(g.getWithPopup, null, t),\n        getWithRedirect: v.bind(g.getWithRedirect, null, t),\n        parseFromUrl: v.bind(g.parseFromUrl, null, t),\n        decode: g.decodeToken,\n        revoke: v.bind(g.revokeToken, null, t),\n        renew: v.bind(g.renewToken, null, t),\n        getUserInfo: v.bind(g.getUserInfo, null, t),\n        verify: v.bind(g.verifyToken, null, t),\n        isLoginRedirect: v.bind(h.isLoginRedirect, null, t)\n      };\n      var r = [\"decode\", \"isLoginRedirect\"];\n      Object.keys(t.token).forEach(function (e) {\n        if (!(r.indexOf(e) >= 0)) {\n          var n = t.token[e];\n          t.token[e] = v.bind(w.prototype.push, t._tokenQueue, n, null);\n        }\n      }), t.token.getWithRedirect._setLocation = function (e) {\n        window.location = e;\n      }, t.token.parseFromUrl._getHistory = function () {\n        return window.history;\n      }, t.token.parseFromUrl._getLocation = function () {\n        return window.location;\n      }, t.token.parseFromUrl._getDocument = function () {\n        return window.document;\n      }, t.fingerprint._getUserAgent = function () {\n        return navigator.userAgent;\n      };\n      var o = /windows phone|iemobile|wpdesktop/i;\n      t.features.isFingerprintSupported = function () {\n        var e = t.fingerprint._getUserAgent();\n\n        return e && !o.test(e);\n      }, t.emitter = new a(), t.tokenManager = new m(t, e.tokenManager), t.tokenManager.on(\"error\", this._onTokenManagerError, this);\n    }\n\n    var i = r(8),\n        s = r(9),\n        a = r(17),\n        u = r(1),\n        c = r(18),\n        l = r(3),\n        f = r(2).storage,\n        p = r(4),\n        h = r(5),\n        d = r(21),\n        g = r(22),\n        m = r(26),\n        y = r(10),\n        v = r(0),\n        w = r(28),\n        T = o.prototype;\n    T._onTokenManagerError = function (e) {\n      \"login_required\" === e.errorCode && e.accessToken && (this.options.onSessionExpired ? this.options.onSessionExpired() : console.error(\"Session has expired or was closed outside the application.\"));\n    }, T.features = {}, T.features.isPopupPostMessageSupported = function () {\n      var e = document.documentMode && document.documentMode < 10;\n      return !(!window.postMessage || e);\n    }, T.features.isTokenVerifySupported = function () {\n      return \"undefined\" != typeof crypto && crypto.subtle && \"undefined\" != typeof Uint8Array;\n    }, T.features.hasTextEncoder = function () {\n      return \"undefined\" != typeof TextEncoder;\n    }, T.features.isPKCESupported = function () {\n      return T.features.isTokenVerifySupported() && T.features.hasTextEncoder();\n    }, T.features.isHTTPS = function () {\n      return \"https:\" === window.location.protocol;\n    }, T.features.isLocalhost = function () {\n      return \"localhost\" === window.location.hostname;\n    }, T.signIn = function (e) {\n      function t(t) {\n        return delete e.sendFingerprint, y.postToTransaction(r, \"/api/v1/authn\", e, t);\n      }\n\n      var r = this;\n      return e = v.clone(e || {}), e.sendFingerprint ? r.fingerprint().then(function (e) {\n        return t({\n          headers: {\n            \"X-Device-Fingerprint\": e\n          }\n        });\n      }) : t();\n    }, T.closeSession = function () {\n      var e = this;\n      return e.tokenManager.clear(), e.session.close().catch(function (e) {\n        if (\"AuthApiError\" !== e.name || \"E0000007\" !== e.errorCode) throw e;\n      });\n    }, T.revokeAccessToken = function () {\n      function e(e) {\n        return t.apply(this, arguments);\n      }\n\n      var t = s(i.mark(function e(t) {\n        var r;\n        return i.wrap(function (e) {\n          for (;;) switch (e.prev = e.next) {\n            case 0:\n              if (r = this, t) {\n                e.next = 6;\n                break;\n              }\n\n              return e.next = 4, r.tokenManager.get(l.ACCESS_TOKEN_STORAGE_KEY);\n\n            case 4:\n              t = e.sent, r.tokenManager.remove(l.ACCESS_TOKEN_STORAGE_KEY);\n\n            case 6:\n              if (t) {\n                e.next = 8;\n                break;\n              }\n\n              return e.abrupt(\"return\", Promise.resolve());\n\n            case 8:\n              return e.abrupt(\"return\", r.token.revoke(t));\n\n            case 9:\n            case \"end\":\n              return e.stop();\n          }\n        }, e, this);\n      }));\n      return e;\n    }(), T.signOut = function () {\n      var e = s(i.mark(function e(t) {\n        var r, n, o, s, a, u, c, f, p, d, g;\n        return i.wrap(function (e) {\n          for (;;) switch (e.prev = e.next) {\n            case 0:\n              if (t = v.extend({}, t), r = window.location.origin, n = window.location.href, o = t.postLogoutRedirectUri || this.options.postLogoutRedirectUri || r, s = t.accessToken, a = !1 !== t.revokeAccessToken, u = t.idToken, c = this, f = h.getOAuthUrls(c).logoutUrl, void 0 !== u) {\n                e.next = 13;\n                break;\n              }\n\n              return e.next = 12, c.tokenManager.get(l.ID_TOKEN_STORAGE_KEY);\n\n            case 12:\n              u = e.sent;\n\n            case 13:\n              if (!a || void 0 !== s) {\n                e.next = 17;\n                break;\n              }\n\n              return e.next = 16, c.tokenManager.get(l.ACCESS_TOKEN_STORAGE_KEY);\n\n            case 16:\n              s = e.sent;\n\n            case 17:\n              if (c.tokenManager.clear(), !a || !s) {\n                e.next = 21;\n                break;\n              }\n\n              return e.next = 21, c.revokeAccessToken(s);\n\n            case 21:\n              if (u) {\n                e.next = 23;\n                break;\n              }\n\n              return e.abrupt(\"return\", c.closeSession().then(function () {\n                o === n ? window.location.reload() : window.location.assign(o);\n              }));\n\n            case 23:\n              p = t.state, d = u.idToken, g = f + \"?id_token_hint=\" + encodeURIComponent(d) + \"&post_logout_redirect_uri=\" + encodeURIComponent(o), p && (g += \"&state=\" + encodeURIComponent(p)), window.location.assign(g);\n\n            case 28:\n            case \"end\":\n              return e.stop();\n          }\n        }, e, this);\n      }));\n      return function (t) {\n        return e.apply(this, arguments);\n      };\n    }(), c.addSharedPrototypes(T), T.webfinger = function (e) {\n      var t = \"/.well-known/webfinger\" + v.toQueryParams(e),\n          r = {\n        headers: {\n          Accept: \"application/jrd+json\"\n        }\n      };\n      return p.get(this, t, r);\n    }, T.fingerprint = function (e) {\n      e = e || {};\n      var t = this;\n      if (!t.features.isFingerprintSupported()) return Promise.reject(new u(\"Fingerprinting is not supported on this device\"));\n      var r, n, o;\n      return new Promise(function (i, s) {\n        n = document.createElement(\"iframe\"), n.style.display = \"none\", o = function (e) {\n          if (e && e.data && e.origin === t.getIssuerOrigin()) {\n            try {\n              var r = JSON.parse(e.data);\n            } catch (e) {\n              return;\n            }\n\n            if (r) return \"FingerprintAvailable\" === r.type ? i(r.fingerprint) : void (\"FingerprintServiceReady\" === r.type && e.source.postMessage(JSON.stringify({\n              type: \"GetFingerprint\"\n            }), e.origin));\n          }\n        }, h.addListener(window, \"message\", o), n.src = t.getIssuerOrigin() + \"/auth/services/devicefingerprint\", document.body.appendChild(n), r = setTimeout(function () {\n          s(new u(\"Fingerprinting timed out\"));\n        }, e.timeout || 15e3);\n      }).finally(function () {\n        clearTimeout(r), h.removeListener(window, \"message\", o), document.body.contains(n) && n.parentElement.removeChild(n);\n      });\n    }, e.exports = c.buildOktaAuth(o);\n  }, function (e, t, r) {\n    var n = function (e) {\n      \"use strict\";\n\n      function t(e, t, r, o) {\n        var i = t && t.prototype instanceof n ? t : n,\n            s = Object.create(i.prototype),\n            a = new p(o || []);\n        return s._invoke = u(e, r, a), s;\n      }\n\n      function r(e, t, r) {\n        try {\n          return {\n            type: \"normal\",\n            arg: e.call(t, r)\n          };\n        } catch (e) {\n          return {\n            type: \"throw\",\n            arg: e\n          };\n        }\n      }\n\n      function n() {}\n\n      function o() {}\n\n      function i() {}\n\n      function s(e) {\n        [\"next\", \"throw\", \"return\"].forEach(function (t) {\n          e[t] = function (e) {\n            return this._invoke(t, e);\n          };\n        });\n      }\n\n      function a(e) {\n        function t(n, o, i, s) {\n          var a = r(e[n], e, o);\n\n          if (\"throw\" !== a.type) {\n            var u = a.arg,\n                c = u.value;\n            return c && \"object\" == typeof c && y.call(c, \"__await\") ? Promise.resolve(c.__await).then(function (e) {\n              t(\"next\", e, i, s);\n            }, function (e) {\n              t(\"throw\", e, i, s);\n            }) : Promise.resolve(c).then(function (e) {\n              u.value = e, i(u);\n            }, function (e) {\n              return t(\"throw\", e, i, s);\n            });\n          }\n\n          s(a.arg);\n        }\n\n        function n(e, r) {\n          function n() {\n            return new Promise(function (n, o) {\n              t(e, r, n, o);\n            });\n          }\n\n          return o = o ? o.then(n, n) : n();\n        }\n\n        var o;\n        this._invoke = n;\n      }\n\n      function u(e, t, n) {\n        var o = S;\n        return function (i, s) {\n          if (o === E) throw new Error(\"Generator is already running\");\n\n          if (o === A) {\n            if (\"throw\" === i) throw s;\n            return d();\n          }\n\n          for (n.method = i, n.arg = s;;) {\n            var a = n.delegate;\n\n            if (a) {\n              var u = c(a, n);\n\n              if (u) {\n                if (u === _) continue;\n                return u;\n              }\n            }\n\n            if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) {\n              if (o === S) throw o = A, n.arg;\n              n.dispatchException(n.arg);\n            } else \"return\" === n.method && n.abrupt(\"return\", n.arg);\n            o = E;\n            var l = r(e, t, n);\n\n            if (\"normal\" === l.type) {\n              if (o = n.done ? A : b, l.arg === _) continue;\n              return {\n                value: l.arg,\n                done: n.done\n              };\n            }\n\n            \"throw\" === l.type && (o = A, n.method = \"throw\", n.arg = l.arg);\n          }\n        };\n      }\n\n      function c(e, t) {\n        var n = e.iterator[t.method];\n\n        if (n === g) {\n          if (t.delegate = null, \"throw\" === t.method) {\n            if (e.iterator.return && (t.method = \"return\", t.arg = g, c(e, t), \"throw\" === t.method)) return _;\n            t.method = \"throw\", t.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n          }\n\n          return _;\n        }\n\n        var o = r(n, e.iterator, t.arg);\n        if (\"throw\" === o.type) return t.method = \"throw\", t.arg = o.arg, t.delegate = null, _;\n        var i = o.arg;\n        return i ? i.done ? (t[e.resultName] = i.value, t.next = e.nextLoc, \"return\" !== t.method && (t.method = \"next\", t.arg = g), t.delegate = null, _) : i : (t.method = \"throw\", t.arg = new TypeError(\"iterator result is not an object\"), t.delegate = null, _);\n      }\n\n      function l(e) {\n        var t = {\n          tryLoc: e[0]\n        };\n        1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t);\n      }\n\n      function f(e) {\n        var t = e.completion || {};\n        t.type = \"normal\", delete t.arg, e.completion = t;\n      }\n\n      function p(e) {\n        this.tryEntries = [{\n          tryLoc: \"root\"\n        }], e.forEach(l, this), this.reset(!0);\n      }\n\n      function h(e) {\n        if (e) {\n          var t = e[w];\n          if (t) return t.call(e);\n          if (\"function\" == typeof e.next) return e;\n\n          if (!isNaN(e.length)) {\n            var r = -1,\n                n = function t() {\n              for (; ++r < e.length;) if (y.call(e, r)) return t.value = e[r], t.done = !1, t;\n\n              return t.value = g, t.done = !0, t;\n            };\n\n            return n.next = n;\n          }\n        }\n\n        return {\n          next: d\n        };\n      }\n\n      function d() {\n        return {\n          value: g,\n          done: !0\n        };\n      }\n\n      var g,\n          m = Object.prototype,\n          y = m.hasOwnProperty,\n          v = \"function\" == typeof Symbol ? Symbol : {},\n          w = v.iterator || \"@@iterator\",\n          T = v.asyncIterator || \"@@asyncIterator\",\n          k = v.toStringTag || \"@@toStringTag\";\n      e.wrap = t;\n      var S = \"suspendedStart\",\n          b = \"suspendedYield\",\n          E = \"executing\",\n          A = \"completed\",\n          _ = {},\n          x = {};\n\n      x[w] = function () {\n        return this;\n      };\n\n      var O = Object.getPrototypeOf,\n          U = O && O(O(h([])));\n      U && U !== m && y.call(U, w) && (x = U);\n      var P = i.prototype = n.prototype = Object.create(x);\n      return o.prototype = P.constructor = i, i.constructor = o, i[k] = o.displayName = \"GeneratorFunction\", e.isGeneratorFunction = function (e) {\n        var t = \"function\" == typeof e && e.constructor;\n        return !!t && (t === o || \"GeneratorFunction\" === (t.displayName || t.name));\n      }, e.mark = function (e) {\n        return Object.setPrototypeOf ? Object.setPrototypeOf(e, i) : (e.__proto__ = i, k in e || (e[k] = \"GeneratorFunction\")), e.prototype = Object.create(P), e;\n      }, e.awrap = function (e) {\n        return {\n          __await: e\n        };\n      }, s(a.prototype), a.prototype[T] = function () {\n        return this;\n      }, e.AsyncIterator = a, e.async = function (r, n, o, i) {\n        var s = new a(t(r, n, o, i));\n        return e.isGeneratorFunction(n) ? s : s.next().then(function (e) {\n          return e.done ? e.value : s.next();\n        });\n      }, s(P), P[k] = \"Generator\", P[w] = function () {\n        return this;\n      }, P.toString = function () {\n        return \"[object Generator]\";\n      }, e.keys = function (e) {\n        var t = [];\n\n        for (var r in e) t.push(r);\n\n        return t.reverse(), function r() {\n          for (; t.length;) {\n            var n = t.pop();\n            if (n in e) return r.value = n, r.done = !1, r;\n          }\n\n          return r.done = !0, r;\n        };\n      }, e.values = h, p.prototype = {\n        constructor: p,\n        reset: function (e) {\n          if (this.prev = 0, this.next = 0, this.sent = this._sent = g, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = g, this.tryEntries.forEach(f), !e) for (var t in this) \"t\" === t.charAt(0) && y.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = g);\n        },\n        stop: function () {\n          this.done = !0;\n          var e = this.tryEntries[0],\n              t = e.completion;\n          if (\"throw\" === t.type) throw t.arg;\n          return this.rval;\n        },\n        dispatchException: function (e) {\n          function t(t, n) {\n            return i.type = \"throw\", i.arg = e, r.next = t, n && (r.method = \"next\", r.arg = g), !!n;\n          }\n\n          if (this.done) throw e;\n\n          for (var r = this, n = this.tryEntries.length - 1; n >= 0; --n) {\n            var o = this.tryEntries[n],\n                i = o.completion;\n            if (\"root\" === o.tryLoc) return t(\"end\");\n\n            if (o.tryLoc <= this.prev) {\n              var s = y.call(o, \"catchLoc\"),\n                  a = y.call(o, \"finallyLoc\");\n\n              if (s && a) {\n                if (this.prev < o.catchLoc) return t(o.catchLoc, !0);\n                if (this.prev < o.finallyLoc) return t(o.finallyLoc);\n              } else if (s) {\n                if (this.prev < o.catchLoc) return t(o.catchLoc, !0);\n              } else {\n                if (!a) throw new Error(\"try statement without catch or finally\");\n                if (this.prev < o.finallyLoc) return t(o.finallyLoc);\n              }\n            }\n          }\n        },\n        abrupt: function (e, t) {\n          for (var r = this.tryEntries.length - 1; r >= 0; --r) {\n            var n = this.tryEntries[r];\n\n            if (n.tryLoc <= this.prev && y.call(n, \"finallyLoc\") && this.prev < n.finallyLoc) {\n              var o = n;\n              break;\n            }\n          }\n\n          o && (\"break\" === e || \"continue\" === e) && o.tryLoc <= t && t <= o.finallyLoc && (o = null);\n          var i = o ? o.completion : {};\n          return i.type = e, i.arg = t, o ? (this.method = \"next\", this.next = o.finallyLoc, _) : this.complete(i);\n        },\n        complete: function (e, t) {\n          if (\"throw\" === e.type) throw e.arg;\n          return \"break\" === e.type || \"continue\" === e.type ? this.next = e.arg : \"return\" === e.type ? (this.rval = this.arg = e.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === e.type && t && (this.next = t), _;\n        },\n        finish: function (e) {\n          for (var t = this.tryEntries.length - 1; t >= 0; --t) {\n            var r = this.tryEntries[t];\n            if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), f(r), _;\n          }\n        },\n        catch: function (e) {\n          for (var t = this.tryEntries.length - 1; t >= 0; --t) {\n            var r = this.tryEntries[t];\n\n            if (r.tryLoc === e) {\n              var n = r.completion;\n\n              if (\"throw\" === n.type) {\n                var o = n.arg;\n                f(r);\n              }\n\n              return o;\n            }\n          }\n\n          throw new Error(\"illegal catch attempt\");\n        },\n        delegateYield: function (e, t, r) {\n          return this.delegate = {\n            iterator: h(e),\n            resultName: t,\n            nextLoc: r\n          }, \"next\" === this.method && (this.arg = g), _;\n        }\n      }, e;\n    }(e.exports);\n\n    try {\n      regeneratorRuntime = n;\n    } catch (e) {\n      Function(\"r\", \"regeneratorRuntime = r\")(n);\n    }\n  }, function (e, t) {\n    function r() {}\n\n    r.prototype = {\n      on: function (e, t, r) {\n        var n = this.e || (this.e = {});\n        return (n[e] || (n[e] = [])).push({\n          fn: t,\n          ctx: r\n        }), this;\n      },\n      once: function (e, t, r) {\n        function n() {\n          o.off(e, n), t.apply(r, arguments);\n        }\n\n        var o = this;\n        return n._ = t, this.on(e, n, r);\n      },\n      emit: function (e) {\n        var t = [].slice.call(arguments, 1),\n            r = ((this.e || (this.e = {}))[e] || []).slice(),\n            n = 0,\n            o = r.length;\n\n        for (n; n < o; n++) r[n].fn.apply(r[n].ctx, t);\n\n        return this;\n      },\n      off: function (e, t) {\n        var r = this.e || (this.e = {}),\n            n = r[e],\n            o = [];\n        if (n && t) for (var i = 0, s = n.length; i < s; i++) n[i].fn !== t && n[i].fn._ !== t && o.push(n[i]);\n        return o.length ? r[e] = o : delete r[e], this;\n      }\n    }, e.exports = r;\n  }, function (e, t, r) {\n    function n(e) {\n      if (!e) throw new a(\"No arguments passed to constructor. Required usage: new OktaAuth(args)\");\n      var t = e.issuer;\n      if (!t) throw new a('No issuer passed to constructor. Required usage: new OktaAuth({issuer: \"https://{yourOktaDomain}.com/oauth2/{authServerId}\"})');\n      if (!new RegExp(\"^http?s?://.+\").test(e.issuer)) throw new a('Issuer must be a valid URL. Required usage: new OktaAuth({issuer: \"https://{yourOktaDomain}.com/oauth2/{authServerId}\"})');\n      if (-1 !== t.indexOf(\"-admin.\")) throw new a('Issuer URL passed to constructor contains \"-admin\" in subdomain. Required usage: new OktaAuth({issuer: \"https://{yourOktaDomain}.com})');\n      var r = e.userAgent;\n      if (r && r.template && -1 === r.template.indexOf(\"$OKTA_AUTH_JS\")) throw new a('UserAgentTemplate must include \"$OKTA_AUTH_JS\" placeholder. Required usage: new OktaAuth({userAgentTemplate: \"xxx $OKTA_AUTH_JS xxx\"})');\n    }\n\n    function o(e) {\n      e.getIssuerOrigin = function () {\n        return this.options.issuer.split(\"/oauth2/\")[0];\n      }, e.forgotPassword = function (e) {\n        return u.postToTransaction(this, \"/api/v1/authn/recovery/password\", e);\n      }, e.unlockAccount = function (e) {\n        return u.postToTransaction(this, \"/api/v1/authn/recovery/unlock\", e);\n      }, e.verifyRecoveryToken = function (e) {\n        return u.postToTransaction(this, \"/api/v1/authn/recovery/token\", e);\n      };\n    }\n\n    function i(e) {\n      return function (t, r) {\n        function n(o) {\n          if (!(this instanceof n)) return new n(o);\n          o && (o.storageUtil = t, o.ajaxRequest ? (c.deprecate(\"ajaxRequest is being deprecated, use httpRequestClient attribute instead.\"), o.httpRequestClient = o.ajaxRequest) : o.httpRequestClient || (o.httpRequestClient = r)), c.bind(e, this)(o);\n        }\n\n        return n.prototype = e.prototype, n.prototype.constructor = n, n.features = e.prototype.features, n;\n      };\n    }\n\n    function s(e, t) {\n      var r = e.userAgent || {};\n      return r.value ? r.value : r.template ? r.template.replace(\"$OKTA_AUTH_JS\", t) : t;\n    }\n\n    var a = r(1),\n        u = r(10),\n        c = r(0);\n    e.exports = {\n      addSharedPrototypes: o,\n      buildOktaAuth: i,\n      assertValidConfig: n,\n      getUserAgent: s\n    };\n  }, function (e, t) {\n    function r(e, t) {\n      this.name = \"AuthApiError\", this.message = e.errorSummary, this.errorSummary = e.errorSummary, this.errorCode = e.errorCode, this.errorLink = e.errorLink, this.errorId = e.errorId, this.errorCauses = e.errorCauses, t && (this.xhr = t);\n    }\n\n    r.prototype = new Error(), e.exports = r;\n  }, function (e, t) {\n    function r() {\n      this.name = \"AuthPollStopError\", this.message = \"The poll was stopped by the sdk\";\n    }\n\n    r.prototype = new Error(), e.exports = r;\n  }, function (e, t, r) {\n    function n(e) {\n      return e.session.get().then(function (e) {\n        return \"ACTIVE\" === e.status;\n      }).catch(function () {\n        return !1;\n      });\n    }\n\n    function o(e) {\n      return c.get(e, \"/api/v1/sessions/me\").then(function (t) {\n        var r = u.omit(t, \"_links\");\n        return r.refresh = function () {\n          return c.post(e, u.getLink(t, \"refresh\").href);\n        }, r.user = function () {\n          return c.get(e, u.getLink(t, \"user\").href);\n        }, r;\n      }).catch(function () {\n        return {\n          status: \"INACTIVE\"\n        };\n      });\n    }\n\n    function i(e) {\n      return c.httpRequest(e, {\n        url: e.getIssuerOrigin() + \"/api/v1/sessions/me\",\n        method: \"DELETE\"\n      });\n    }\n\n    function s(e) {\n      return c.post(e, \"/api/v1/sessions/me/lifecycle/refresh\");\n    }\n\n    function a(e, t, r) {\n      r = r || window.location.href, window.location = e.getIssuerOrigin() + \"/login/sessionCookieRedirect\" + u.toQueryParams({\n        checkAccountSetupComplete: !0,\n        token: t,\n        redirectUrl: r\n      });\n    }\n\n    var u = r(0),\n        c = r(4);\n    e.exports = {\n      sessionExists: n,\n      getSession: o,\n      closeSession: i,\n      refreshSession: s,\n      setCookieAndRedirect: a\n    };\n  }, function (e, t, r) {\n    function n(e, t) {\n      return Promise.resolve().then(function () {\n        if (!t || !t.accessToken) throw new R(\"A valid access token object is required\");\n        var r = e.options.clientId;\n        if (!r) throw new R(\"A clientId must be specified in the OktaAuth constructor to revoke a token\");\n        var n = P.getOAuthUrls(e).revokeUrl,\n            o = t.accessToken,\n            i = U.toQueryParams({\n          token_type_hint: \"access_token\",\n          token: o\n        }).slice(1),\n            s = btoa(r);\n        return O.post(e, n, i, {\n          headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            Authorization: \"Basic \" + s\n          }\n        });\n      });\n    }\n\n    function o(e) {\n      var t,\n          r = e.split(\".\");\n\n      try {\n        t = {\n          header: JSON.parse(U.base64UrlToString(r[0])),\n          payload: JSON.parse(U.base64UrlToString(r[1])),\n          signature: r[2]\n        };\n      } catch (e) {\n        throw new R(\"Malformed token\");\n      }\n\n      return t;\n    }\n\n    function i(e, t, r) {\n      return Promise.resolve().then(function () {\n        if (!t || !t.idToken) throw new R(\"Only idTokens may be verified\");\n        var n = o(t.idToken),\n            i = {\n          clientId: e.options.clientId,\n          issuer: e.options.issuer,\n          ignoreSignature: e.options.ignoreSignature\n        };\n        return U.extend(i, r), P.validateClaims(e, n.payload, i), 1 != i.ignoreSignature && e.features.isTokenVerifySupported() ? P.getKey(e, t.issuer, n.header.kid).then(function (e) {\n          return C.verifyToken(t.idToken, e);\n        }).then(function (e) {\n          if (!e) throw new R(\"The token signature is not valid\");\n          if (r && r.accessToken && t.claims.at_hash) return C.getOidcHash(r.accessToken).then(function (e) {\n            if (e !== t.claims.at_hash) throw new R(\"Token hash verification failed\");\n          });\n        }).then(function () {\n          return t;\n        }) : t;\n      });\n    }\n\n    function s(e, t, r) {\n      var n, o;\n      return new Promise(function (i, s) {\n        n = function (t) {\n          if (t.data && t.data.state === r) return t.origin !== e.getIssuerOrigin() ? s(new R(\"The request does not match client configuration\")) : void i(t.data);\n        }, P.addListener(window, \"message\", n), o = setTimeout(function () {\n          s(new R(\"OAuth flow timed out\"));\n        }, t || 12e4);\n      }).finally(function () {\n        clearTimeout(o), P.removeListener(window, \"message\", n);\n      });\n    }\n\n    function a(e, t, r, n) {\n      var o = j.loadMeta(e),\n          i = {\n        clientId: t.clientId,\n        authorizationCode: r,\n        codeVerifier: o.codeVerifier,\n        redirectUri: o.redirectUri\n      };\n      return j.getToken(e, i, n).then(function (e) {\n        return u(e, i), e;\n      }).finally(function () {\n        j.clearMeta(e);\n      });\n    }\n\n    function u(e, t) {\n      if (e.error || e.error_description) throw new I(e.error, e.error_description);\n      if (e.state !== t.state) throw new R(\"OAuth flow response state doesn't match request state\");\n    }\n\n    function c(e, t, r, n) {\n      n = n || {};\n      var o = t.responseType;\n      Array.isArray(o) || (o = [o]);\n      var s = U.clone(t.scopes),\n          c = t.clientId || e.options.clientId,\n          l = !1 !== e.options.pkce;\n      return Promise.resolve().then(function () {\n        return u(r, t), r.code && l ? (o = [\"token\"], -1 !== s.indexOf(\"openid\") && o.push(\"id_token\"), a(e, t, r.code, n)) : r;\n      }).then(function (r) {\n        var o = {},\n            a = r.expires_in,\n            u = r.token_type,\n            l = r.access_token,\n            f = r.id_token;\n\n        if (l && (o.accessToken = {\n          value: l,\n          accessToken: l,\n          expiresAt: Number(a) + Math.floor(Date.now() / 1e3),\n          tokenType: u,\n          scopes: s,\n          authorizeUrl: n.authorizeUrl,\n          userinfoUrl: n.userinfoUrl\n        }), f) {\n          var p = e.token.decode(f),\n              h = {\n            value: f,\n            idToken: f,\n            claims: p.payload,\n            expiresAt: p.payload.exp,\n            scopes: s,\n            authorizeUrl: n.authorizeUrl,\n            issuer: n.issuer,\n            clientId: c\n          },\n              d = {\n            clientId: c,\n            issuer: n.issuer,\n            nonce: t.nonce,\n            accessToken: l\n          };\n          return void 0 !== t.ignoreSignature && (d.ignoreSignature = t.ignoreSignature), i(e, h, d).then(function () {\n            return o.idToken = h, o;\n          });\n        }\n\n        return o;\n      }).then(function (e) {\n        if (-1 !== o.indexOf(\"token\") && !e.accessToken) throw new R('Unable to parse OAuth flow response: response type \"token\" was requested but \"access_token\" was not returned.');\n        if (-1 !== o.indexOf(\"id_token\") && !e.idToken) throw new R('Unable to parse OAuth flow response: response type \"id_token\" was requested but \"id_token\" was not returned.');\n        return {\n          tokens: e,\n          state: r.state,\n          code: r.code\n        };\n      });\n    }\n\n    function l(e) {\n      return {\n        pkce: e.options.pkce,\n        clientId: e.options.clientId,\n        redirectUri: e.options.redirectUri || window.location.href,\n        responseType: [\"token\", \"id_token\"],\n        responseMode: e.options.responseMode,\n        state: P.generateState(),\n        nonce: P.generateNonce(),\n        scopes: [\"openid\", \"email\"],\n        ignoreSignature: e.options.ignoreSignature\n      };\n    }\n\n    function f(e) {\n      if (!e.clientId) throw new R(\"A clientId must be specified in the OktaAuth constructor to get a token\");\n      if (U.isString(e.responseType) && -1 !== e.responseType.indexOf(\" \")) throw new R(\"Multiple OAuth responseTypes must be defined as an array\");\n      var t = U.removeNils({\n        client_id: e.clientId,\n        code_challenge: e.codeChallenge,\n        code_challenge_method: e.codeChallengeMethod,\n        display: e.display,\n        idp: e.idp,\n        idp_scope: e.idpScope,\n        login_hint: e.loginHint,\n        max_age: e.maxAge,\n        nonce: e.nonce,\n        prompt: e.prompt,\n        redirect_uri: e.redirectUri,\n        response_mode: e.responseMode,\n        response_type: e.responseType,\n        sessionToken: e.sessionToken,\n        state: e.state\n      });\n      if ([\"idp_scope\", \"response_type\"].forEach(function (e) {\n        Array.isArray(t[e]) && (t[e] = t[e].join(\" \"));\n      }), -1 !== e.responseType.indexOf(\"id_token\") && -1 === e.scopes.indexOf(\"openid\")) throw new R(\"openid scope must be specified in the scopes argument when requesting an id_token\");\n      return t.scope = e.scopes.join(\" \"), t;\n    }\n\n    function p(e) {\n      var t = f(e);\n      return U.toQueryParams(t);\n    }\n\n    function h(e, t) {\n      return arguments.length > 2 ? Promise.reject(new R('As of version 3.0, \"getToken\" takes only a single set of options')) : (t = t || {}, m(e, t).then(function (r) {\n        var n = {\n          prompt: \"none\",\n          responseMode: \"okta_post_message\",\n          display: null\n        },\n            o = {\n          display: \"popup\"\n        };\n        t.sessionToken ? U.extend(r, n) : t.idp && U.extend(r, o);\n        var i, a, u;\n        u = P.getOAuthUrls(e, r), a = t.codeVerifier ? u.tokenUrl : u.authorizeUrl, i = a + p(r);\n\n        switch (r.sessionToken || null === r.display ? \"IFRAME\" : \"popup\" === r.display ? \"POPUP\" : \"IMPLICIT\") {\n          case \"IFRAME\":\n            var l = s(e, t.timeout, r.state),\n                f = P.loadFrame(i);\n            return l.then(function (t) {\n              return c(e, r, t, u);\n            }).finally(function () {\n              document.body.contains(f) && f.parentElement.removeChild(f);\n            });\n\n          case \"POPUP\":\n            var h;\n\n            if (\"okta_post_message\" === r.responseMode) {\n              if (!e.features.isPopupPostMessageSupported()) throw new R(\"This browser doesn't have full postMessage support\");\n              h = s(e, t.timeout, r.state);\n            }\n\n            var d = {\n              popupTitle: t.popupTitle\n            },\n                g = P.loadPopup(i, d);\n            return new Promise(function (e, t) {\n              var r = setInterval(function () {\n                g && !g.closed || (clearInterval(r), t(new R(\"Unable to parse OAuth flow response\")));\n              }, 100);\n              h.then(function (t) {\n                clearInterval(r), e(t);\n              }).catch(function (e) {\n                clearInterval(r), t(e);\n              });\n            }).then(function (t) {\n              return c(e, r, t, u);\n            }).finally(function () {\n              g && !g.closed && g.close();\n            });\n\n          default:\n            throw new R(\"The full page redirect flow is not supported\");\n        }\n      }).catch(function (t) {\n        throw e.options.pkce && j.clearMeta(e), t;\n      }));\n    }\n\n    function d(e, t) {\n      return arguments.length > 2 ? Promise.reject(new R('As of version 3.0, \"getWithoutPrompt\" takes only a single set of options')) : (t = U.clone(t) || {}, U.extend(t, {\n        prompt: \"none\",\n        responseMode: \"okta_post_message\",\n        display: null\n      }), h(e, t));\n    }\n\n    function g(e, t) {\n      return arguments.length > 2 ? Promise.reject(new R('As of version 3.0, \"getWithPopup\" takes only a single set of options')) : (t = U.clone(t) || {}, U.extend(t, {\n        display: \"popup\",\n        responseMode: \"okta_post_message\"\n      }), h(e, t));\n    }\n\n    function m(e, t) {\n      if (P.isLoginRedirect(e)) return Promise.reject(new R(\"The app should not attempt to call getToken on callback. Authorize flow is already in process. Use parseFromUrl() to receive tokens.\"));\n      t = U.clone(t) || {};\n      var r = l(e);\n      if (U.extend(r, t), !1 === r.pkce) return Promise.resolve(r);\n\n      if (!e.features.isPKCESupported()) {\n        var n = \"PKCE requires a modern browser with encryption support running in a secure context.\";\n        return e.features.isHTTPS() || (n += \"\\nThe current page is not being served with HTTPS protocol. PKCE requires secure HTTPS protocol.\"), e.features.hasTextEncoder() || (n += '\\n\"TextEncoder\" is not defined. To use PKCE, you may need to include a polyfill/shim for this browser.'), Promise.reject(new R(n));\n      }\n\n      return r.codeChallengeMethod || (r.codeChallengeMethod = j.DEFAULT_CODE_CHALLENGE_METHOD), r.responseType = \"code\", P.getWellKnown(e, null).then(function (e) {\n        if (-1 === (e.code_challenge_methods_supported || []).indexOf(r.codeChallengeMethod)) throw new R(\"Invalid code_challenge_method\");\n      }).then(function () {\n        var t = j.generateVerifier(r.codeVerifier),\n            n = {\n          codeVerifier: t,\n          redirectUri: r.redirectUri\n        };\n        return j.saveMeta(e, n), j.computeChallenge(t);\n      }).then(function (e) {\n        var t = U.clone(r) || {};\n        return U.extend(t, r, {\n          codeChallenge: e\n        }), t;\n      });\n    }\n\n    function y(e, t, r) {\n      var n = t.responseType,\n          o = t.state,\n          i = t.nonce,\n          s = t.scopes,\n          a = t.clientId,\n          u = t.ignoreSignature,\n          c = JSON.stringify({\n        responseType: n,\n        state: o,\n        nonce: i,\n        scopes: s,\n        clientId: a,\n        urls: r,\n        ignoreSignature: u\n      });\n      M.browserHasSessionStorage() ? M.getSessionStorage().setItem(L.REDIRECT_OAUTH_PARAMS_NAME, c) : N.set(L.REDIRECT_OAUTH_PARAMS_NAME, c, null, e.options.cookies);\n    }\n\n    function v(e, t) {\n      return arguments.length > 2 ? Promise.reject(new R('As of version 3.0, \"getWithRedirect\" takes only a single set of options')) : (t = U.clone(t) || {}, m(e, t).then(function (r) {\n        var n = P.getOAuthUrls(e, t),\n            o = n.authorizeUrl + p(r);\n        y(e, r, n), N.set(L.REDIRECT_NONCE_COOKIE_NAME, r.nonce, null, e.options.cookies), N.set(L.REDIRECT_STATE_COOKIE_NAME, r.state, null, e.options.cookies), e.token.getWithRedirect._setLocation(o);\n      }));\n    }\n\n    function w(e, t) {\n      if (!P.isToken(t)) return Promise.reject(new R(\"Renew must be passed a token with an array of scopes and an accessToken or idToken\"));\n      var r;\n      return r = e.options.pkce ? \"code\" : t.accessToken ? \"token\" : \"id_token\", d(e, {\n        responseType: r,\n        scopes: t.scopes,\n        authorizeUrl: t.authorizeUrl,\n        userinfoUrl: t.userinfoUrl,\n        issuer: t.issuer\n      }).then(function (e) {\n        var r = e.tokens;\n        return t.idToken ? r.idToken : r.accessToken;\n      });\n    }\n\n    function T(e) {\n      var t = e.token.parseFromUrl._getHistory(),\n          r = e.token.parseFromUrl._getDocument(),\n          n = e.token.parseFromUrl._getLocation();\n\n      t && t.replaceState ? t.replaceState(null, r.title, n.pathname + n.search) : n.hash = \"\";\n    }\n\n    function k(e) {\n      var t = e.token.parseFromUrl._getHistory(),\n          r = e.token.parseFromUrl._getDocument(),\n          n = e.token.parseFromUrl._getLocation();\n\n      t && t.replaceState ? t.replaceState(null, r.title, n.pathname + n.hash) : n.search = \"\";\n    }\n\n    function S() {\n      var e = N.get(L.REDIRECT_OAUTH_PARAMS_NAME);\n\n      if (N.delete(L.REDIRECT_OAUTH_PARAMS_NAME), !e && M.browserHasSessionStorage()) {\n        var t = M.getSessionStorage();\n        e = t.getItem(L.REDIRECT_OAUTH_PARAMS_NAME), t.removeItem(L.REDIRECT_OAUTH_PARAMS_NAME);\n      }\n\n      return e;\n    }\n\n    function b(e, t) {\n      t = t || {}, U.isString(t) && (t = {\n        url: t\n      });\n\n      var r,\n          n = e.options.pkce ? \"query\" : \"fragment\",\n          o = t.url,\n          i = t.responseMode || e.options.responseMode || n,\n          s = e.token.parseFromUrl._getLocation();\n\n      if (!(r = \"query\" === i ? o ? o.substring(o.indexOf(\"?\")) : s.search : o ? o.substring(o.indexOf(\"#\")) : s.hash)) return Promise.reject(new R(\"Unable to parse a token from the url\"));\n      var a = S();\n      if (!a) return Promise.reject(new R(\"Unable to retrieve OAuth redirect params from storage\"));\n\n      try {\n        var u = JSON.parse(a),\n            l = u.urls;\n        delete u.urls;\n      } catch (e) {\n        return Promise.reject(new R(\"Unable to parse the \" + L.REDIRECT_OAUTH_PARAMS_NAME + \" value from storage: \" + e.message));\n      }\n\n      return Promise.resolve(P.urlParamsToObject(r)).then(function (t) {\n        return o || (\"query\" === i ? k(e) : T(e)), c(e, u, t, l);\n      });\n    }\n\n    function E(e, t, r) {\n      return A.apply(this, arguments);\n    }\n\n    function A() {\n      return A = x(_.mark(function e(t, r, n) {\n        return _.wrap(function (e) {\n          for (;;) switch (e.prev = e.next) {\n            case 0:\n              if (r) {\n                e.next = 4;\n                break;\n              }\n\n              return e.next = 3, t.tokenManager.get(L.ACCESS_TOKEN_STORAGE_KEY);\n\n            case 3:\n              r = e.sent;\n\n            case 4:\n              if (n) {\n                e.next = 8;\n                break;\n              }\n\n              return e.next = 7, t.tokenManager.get(L.ID_TOKEN_STORAGE_KEY);\n\n            case 7:\n              n = e.sent;\n\n            case 8:\n              if (r && (P.isToken(r) || r.accessToken || r.userinfoUrl)) {\n                e.next = 10;\n                break;\n              }\n\n              return e.abrupt(\"return\", Promise.reject(new R(\"getUserInfo requires an access token object\")));\n\n            case 10:\n              if (n && (P.isToken(n) || n.idToken)) {\n                e.next = 12;\n                break;\n              }\n\n              return e.abrupt(\"return\", Promise.reject(new R(\"getUserInfo requires an ID token object\")));\n\n            case 12:\n              return e.abrupt(\"return\", O.httpRequest(t, {\n                url: r.userinfoUrl,\n                method: \"GET\",\n                accessToken: r.accessToken\n              }).then(function (e) {\n                return e.sub === n.claims.sub ? e : Promise.reject(new R(\"getUserInfo request was rejected due to token mismatch\"));\n              }).catch(function (e) {\n                if (e.xhr && (401 === e.xhr.status || 403 === e.xhr.status)) {\n                  var t;\n\n                  if (e.xhr.headers && U.isFunction(e.xhr.headers.get) && e.xhr.headers.get(\"WWW-Authenticate\") ? t = e.xhr.headers.get(\"WWW-Authenticate\") : U.isFunction(e.xhr.getResponseHeader) && (t = e.xhr.getResponseHeader(\"WWW-Authenticate\")), t) {\n                    var r = t.match(/error=\"(.*?)\"/) || [],\n                        n = t.match(/error_description=\"(.*?)\"/) || [],\n                        o = r[1],\n                        i = n[1];\n                    o && i && (e = new I(o, i));\n                  }\n                }\n\n                throw e;\n              }));\n\n            case 13:\n            case \"end\":\n              return e.stop();\n          }\n        }, e);\n      })), A.apply(this, arguments);\n    }\n\n    var _ = r(8),\n        x = r(9),\n        O = r(4),\n        U = r(0),\n        P = r(5),\n        C = r(23),\n        R = r(1),\n        I = r(24),\n        L = r(3),\n        N = r(2).storage,\n        M = r(2),\n        j = r(25);\n\n    e.exports = {\n      revokeToken: n,\n      getToken: h,\n      getWithoutPrompt: d,\n      getWithPopup: g,\n      getWithRedirect: v,\n      parseFromUrl: b,\n      decodeToken: o,\n      renewToken: w,\n      getUserInfo: E,\n      verifyToken: i,\n      handleOAuthResponse: c,\n      prepareOauthParams: m\n    };\n  }, function (e, t, r) {\n    function n(e) {\n      var t = new TextEncoder().encode(e);\n      return crypto.subtle.digest(\"SHA-256\", t).then(function (e) {\n        var t = new Uint8Array(e),\n            r = t.slice(0, 16),\n            n = String.fromCharCode.apply(null, r);\n        return i.stringToBase64Url(n);\n      });\n    }\n\n    function o(e, t) {\n      t = i.clone(t);\n      var r = {\n        name: \"RSASSA-PKCS1-v1_5\",\n        hash: {\n          name: \"SHA-256\"\n        }\n      },\n          n = [\"verify\"];\n      return delete t.use, crypto.subtle.importKey(\"jwk\", t, r, !0, n).then(function (t) {\n        var n = e.split(\".\"),\n            o = i.stringToBuffer(n[0] + \".\" + n[1]),\n            s = i.base64UrlDecode(n[2]),\n            a = i.stringToBuffer(s);\n        return crypto.subtle.verify(r, t, a, o);\n      });\n    }\n\n    var i = r(0);\n    e.exports = {\n      getOidcHash: n,\n      verifyToken: o\n    };\n  }, function (e, t) {\n    function r(e, t) {\n      this.name = \"OAuthError\", this.message = t, this.errorCode = e, this.errorSummary = t;\n    }\n\n    r.prototype = new Error(), e.exports = r;\n  }, function (e, t, r) {\n    function n(e) {\n      return (\"0\" + e.toString(16)).substr(-2);\n    }\n\n    function o(e) {\n      var t = new Uint8Array(Math.ceil(e / 2));\n      return crypto.getRandomValues(t), Array.from(t, n).join(\"\").slice(0, e);\n    }\n\n    function i(e) {\n      var t = e || \"\";\n      return t.length < y && (t += o(y - t.length)), encodeURIComponent(t).slice(0, v);\n    }\n\n    function s(e, t) {\n      return t = m.extend({}, e.options.cookies, t), e.options.storageUtil.getPKCEStorage(t);\n    }\n\n    function a(e, t) {\n      var r = s(e, {\n        preferLocalStorage: !0\n      }),\n          n = r.getStorage();\n      n.codeVerifier && m.warn(\"saveMeta: PKCE codeVerifier exists in localStorage. This may indicate an auth flow is already in progress.\"), r = s(e), n = r.getStorage(), n.codeVerifier && m.warn(\"saveMeta: PKCE codeVerifier exists in sessionStorage. This may indicate an auth flow is already in progress.\"), c(e), r.setStorage(t);\n    }\n\n    function u(e) {\n      var t = s(e, {\n        preferLocalStorage: !0\n      }),\n          r = t.getStorage();\n      if (!r.codeVerifier && (t = s(e, {\n        preferLocalStorage: !1\n      }), r = t.getStorage(), !r.codeVerifier)) throw new d(\"Could not load PKCE codeVerifier from storage. This may indicate the auth flow has already completed or multiple auth flows are executing concurrently.\", null);\n      return r;\n    }\n\n    function c(e) {\n      var t = s(e);\n      t.clearStorage(), t = s(e, {\n        preferLocalStorage: !0\n      }), t.clearStorage();\n    }\n\n    function l(e) {\n      var t = new TextEncoder().encode(e);\n      return crypto.subtle.digest(\"SHA-256\", t).then(function (e) {\n        var t = String.fromCharCode.apply(null, new Uint8Array(e));\n        return m.stringToBase64Url(t);\n      });\n    }\n\n    function f(e) {\n      if (!e.clientId) throw new d(\"A clientId must be specified in the OktaAuth constructor to get a token\");\n      if (!e.redirectUri) throw new d(\"The redirectUri passed to /authorize must also be passed to /token\");\n      if (!e.authorizationCode) throw new d(\"An authorization code (returned from /authorize) must be passed to /token\");\n      if (!e.codeVerifier) throw new d('The \"codeVerifier\" (generated and saved by your app) must be passed to /token');\n    }\n\n    function p(e) {\n      var t = m.removeNils({\n        client_id: e.clientId,\n        redirect_uri: e.redirectUri,\n        grant_type: \"authorization_code\",\n        code: e.authorizationCode,\n        code_verifier: e.codeVerifier\n      });\n      return m.toQueryParams(t).slice(1);\n    }\n\n    function h(e, t, r) {\n      f(t);\n      var n = p(t);\n      return g.httpRequest(e, {\n        url: r.tokenUrl,\n        method: \"POST\",\n        args: n,\n        withCredentials: !1,\n        headers: {\n          \"Content-Type\": \"application/x-www-form-urlencoded\"\n        }\n      });\n    }\n\n    var d = r(1),\n        g = r(4),\n        m = r(0),\n        y = 43,\n        v = 128;\n    e.exports = {\n      DEFAULT_CODE_CHALLENGE_METHOD: \"S256\",\n      generateVerifier: i,\n      clearMeta: c,\n      saveMeta: a,\n      loadMeta: u,\n      computeChallenge: l,\n      getToken: h\n    };\n  }, function (e, t, r) {\n    function n(e, t) {\n      return t.expiresAt - e.options.expireEarlySeconds;\n    }\n\n    function o(e, t) {\n      return n(e, t) <= e.clock.now();\n    }\n\n    function i(e, t, r) {\n      e.emitter.emit(\"expired\", t, r);\n    }\n\n    function s(e, t) {\n      e.emitter.emit(\"error\", t);\n    }\n\n    function a(e, t) {\n      clearTimeout(e.expireTimeouts[t]), delete e.expireTimeouts[t], delete e.renewPromise[t];\n    }\n\n    function u(e) {\n      var t = e.expireTimeouts;\n\n      for (var r in t) t.hasOwnProperty(r) && a(e, r);\n    }\n\n    function c(e, t, r, o) {\n      var s = n(t, o),\n          u = 1e3 * Math.max(s - t.clock.now(), 0);\n      a(t, r);\n      var c = setTimeout(function () {\n        i(t, r, o);\n      }, u);\n      t.expireTimeouts[r] = c;\n    }\n\n    function l(e, t, r) {\n      try {\n        var n = r.getStorage();\n      } catch (e) {\n        return void s(t, e);\n      }\n\n      for (var o in n) if (n.hasOwnProperty(o)) {\n        var i = n[o];\n        c(e, t, o, i);\n      }\n    }\n\n    function f(e, t, r, n, o) {\n      var i = r.getStorage();\n      if (!w.isObject(o) || !o.scopes || !o.expiresAt && 0 !== o.expiresAt || !o.idToken && !o.accessToken) throw new T(\"Token must be an Object with scopes, expiresAt, and an idToken or accessToken properties\");\n      i[n] = o, r.setStorage(i), c(e, t, n, o);\n    }\n\n    function p(e, t) {\n      return e.getStorage()[t];\n    }\n\n    function h(e, t, r, n) {\n      return new Promise(function (i, s) {\n        if (t.options.autoRenew && A.isLoginRedirect(e)) return s(new T(\"The app should not attempt to call authorize API on callback. Authorize flow is already in process. Use parseFromUrl() to receive tokens.\"));\n        var a = p(r, n);\n        return i(a && o(t, a) ? t.options.autoRenew ? g(e, t, r, n) : d(t, r, n) : a);\n      });\n    }\n\n    function d(e, t, r) {\n      a(e, r);\n      var n = t.getStorage();\n      delete n[r], t.setStorage(n);\n    }\n\n    function g(e, t, r, n) {\n      var o = t.renewPromise[n];\n      if (o) return o;\n\n      try {\n        var i = p(r, n);\n        if (!i) throw new T(\"The tokenManager has no token for the key: \" + n);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      return a(t, n), t.renewPromise[n] = e.token.renew(i).then(function (o) {\n        var i = p(r, n);\n        if (i) return f(e, t, r, n, o), t.emitter.emit(\"renewed\", n, o, i), o;\n      }).catch(function (e) {\n        throw \"OAuthError\" !== e.name && \"AuthSdkError\" !== e.name || (d(t, r, n), e.tokenKey = n, e.accessToken = !!i.accessToken, s(t, e)), e;\n      }).finally(function () {\n        delete t.renewPromise[n];\n      }), t.renewPromise[n];\n    }\n\n    function m(e, t) {\n      u(e), t.clearStorage();\n    }\n\n    function y(e, t) {\n      t = w.extend({}, _, w.removeNils(t)), \"localStorage\" !== t.storage || k.browserHasLocalStorage() || (w.warn(\"This browser doesn't support localStorage. Switching to sessionStorage.\"), t.storage = \"sessionStorage\"), \"sessionStorage\" !== t.storage || k.browserHasSessionStorage() || (w.warn(\"This browser doesn't support sessionStorage. Switching to cookie-based storage.\"), t.storage = \"cookie\");\n      var r;\n      if (\"object\" === v(t.storage)) r = t.storage;else switch (t.storage) {\n        case \"localStorage\":\n          r = localStorage;\n          break;\n\n        case \"sessionStorage\":\n          r = sessionStorage;\n          break;\n\n        case \"cookie\":\n          r = function (e) {\n            var t = k.getCookieStorage(e);\n            return {\n              getItem: function (e) {\n                var r = t.getItem(),\n                    n = {};\n                return Object.keys(r).forEach(function (t) {\n                  0 === t.indexOf(e) && (n[t.replace(\"\".concat(e, \"_\"), \"\")] = JSON.parse(r[t]));\n                }), JSON.stringify(n);\n              },\n              setItem: function (e, r) {\n                var n = JSON.parse(this.getItem(e));\n                r = JSON.parse(r), Object.keys(r).forEach(function (o) {\n                  var i = e + \"_\" + o,\n                      s = JSON.stringify(r[o]);\n                  t.setItem(i, s), delete n[o];\n                }), Object.keys(n).forEach(function (t) {\n                  k.storage.delete(e + \"_\" + t);\n                });\n              }\n            };\n          }(e.options.cookies);\n\n          break;\n\n        case \"memory\":\n          r = k.getInMemoryStorage();\n          break;\n\n        default:\n          throw new T(\"Unrecognized storage option\");\n      }\n      var n = t.storageKey || S.TOKEN_STORAGE_NAME,\n          o = b(r, n),\n          i = E.create(e, t),\n          s = {\n        clock: i,\n        options: t,\n        emitter: e.emitter,\n        expireTimeouts: {},\n        renewPromise: {}\n      };\n      this.add = w.bind(f, this, e, s, o), this.get = w.bind(h, this, e, s, o), this.remove = w.bind(d, this, s, o), this.clear = w.bind(m, this, s, o), this.renew = w.bind(g, this, e, s, o), this.on = w.bind(s.emitter.on, s.emitter), this.off = w.bind(s.emitter.off, s.emitter), l(e, s, o);\n    }\n\n    var v = r(6),\n        w = r(0),\n        T = r(1),\n        k = r(2),\n        S = r(3),\n        b = r(7),\n        E = r(27),\n        A = r(5),\n        _ = {\n      autoRenew: !0,\n      storage: \"localStorage\",\n      expireEarlySeconds: 30\n    };\n    e.exports = y;\n  }, function (e, t, r) {\n    function n(e) {\n      this.localOffset = parseInt(e || 0);\n    }\n\n    r(0).extend(n.prototype, {\n      now: function () {\n        return (Date.now() + this.localOffset) / 1e3;\n      }\n    }), n.create = function () {\n      return new n(0);\n    }, e.exports = n;\n  }, function (e, t, r) {\n    function n() {\n      this.queue = [], this.running = !1;\n    }\n\n    var o = r(0);\n    o.extend(n.prototype, {\n      push: function () {\n        var e = this,\n            t = Array.prototype.slice.call(arguments),\n            r = t[0],\n            n = t[1];\n        return t = t.slice(2), new Promise(function (o, i) {\n          e.queue.push({\n            method: r,\n            thisObject: n,\n            args: t,\n            resolve: o,\n            reject: i\n          }), e.run();\n        });\n      },\n      run: function () {\n        var e = this;\n\n        if (!this.running && 0 !== this.queue.length) {\n          this.running = !0;\n          var t = this.queue.shift(),\n              r = t.method.apply(t.thisObject, t.args);\n          o.isPromise(r) ? r.then(t.resolve, t.reject).finally(function () {\n            e.running = !1, e.run();\n          }) : (t.resolve(r), this.running = !1, this.run());\n        }\n      }\n    }), e.exports = n;\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}